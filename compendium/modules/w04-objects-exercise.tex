%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution


\Exercise{\ExeWeekFOUR}\label{exe:W04}
\begin{Goals}
\input{modules/w04-objects-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{04}
\item Läs om hur man fixar buggar i appendix \ref{appendix:debug}.
\end{Preparations}

\else

\ExerciseSolution{\ExeWeekFOUR}

\fi



\BasicTasks %%%%%%%%%%%%%%%%


\WHAT{Para ihop begrepp med beskrivning.}

\QUESTBEGIN

\Task \what

\vspace{1em}\noindent Koppla varje begrepp med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w04-concepts-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w04-concepts-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND


%%%% Översikt av strukturen i grundövningarna:
%%%% tupler
%%%% objekt
%%%% ladda ner introprog och använd classpath till REPL
%%%% introprog.PixelWindow
%%%% java.awt.Color
%%%% paket


\WHAT{Nästlade singelobjekt, import, synlighet och punktnotation.}

\QUESTBEGIN

\Task \what~I den tvådimensionella Underjorden bor Mullvaden och Masken. Masken har gömt sig för Mullvaden och befinner sig på en plats långt bort. Masken har även gjort delar av sin position osynlig för omvärlden:

\begin{Code}
object Underjorden:
  var x = 0
  var y = 1

  object Mullvaden:
    var x = Underjorden.x + 10
    var y = Underjorden.y + 9

  object Masken:
    private var x = Mullvaden.x
    var y = Mullvaden.y + 190
    def ärMullvadsmat: Boolean = ???
\end{Code}

\Subtask Skapa ovan kod i filen \code{Underjorden.scala} med en editor och implementera predikatet  \code{ärMullvadsmat} så att det blir sant om mullvadens koordinater är samma som maskens.

\Subtask Testa livet i Underjorden genom att klistra in din modul i REPL. Importera Underjordens medlemmar med asterisk så att du ser Mullvaden och Masken. Flytta med hjälp av tilldelning Maskens y-koordinat så att Masken hamnar på samma plats som Mullvaden. Kontrollera att predikatet \code{ärMullvadsmat} fungerar som tänkt.

 \Subtask Importera därefter allt i Mullvaden och sedan allt i Masken och tilldela \code{x} ett nytt värde enligt raderna 1--3 nedan. Vad ger uttrycken på raderna 4--6 nedan för värde? Förklara vad som händer i termer av namnöverskuggning och synlighet?

\begin{REPL}
scala> import Mullvaden.*
scala> import Masken.*
scala> x = -1
scala> Mullvaden.x
scala> Masken.x
scala> Underjorden.x
\end{REPL}

\SOLUTION

\TaskSolved \what

\SubtaskSolved

\begin{Code}
object Underjorden:
  var x = 0
  var y = 1

  object Mullvaden:
    var x = Underjorden.x + 10
    var y = Underjorden.y + 9

  object Masken:
    private var x = Mullvaden.x
    var y = Mullvaden.y + 190
    def ärMullvadsmat: Boolean = x == Mullvaden.x && y == Mullvaden.y
\end{Code}

\SubtaskSolved

\begin{REPL}
scala> :load Underjorden.scala
scala> import Underjorden.*
scala> Masken.ärMullvadsmat
val res0: Boolean = false
scala> Masken.y = Mullvaden.y
scala> Masken.ärMullvadsmat
val res1: Boolean = true
\end{REPL}


\SubtaskSolved

\begin{REPL}
scala> import Mullvaden.*
scala> import Masken.*
scala> x = -1
scala> Mullvaden.x
val res2: Int = -1

scala> Masken.x
1 |Masken.x
  |^^^^^^^^
  |variable x cannot be accessed as a member of Underjorden.Masken.type from module class rs\$line\$9\$.

scala> Underjorden.x
val res3: Int = 0
\end{REPL}

\noindent \emph{Förklaring:} När importen av Maskens alla synliga medlemmar sker kommer de som ej är privata att överskugga andra medlemmar med samma namn. Det är Mullvadens \code{x}-variabel som tilldelas \code{-1} eftersom Maskens \code{x} är privat och ej syns utåt. Underjordens medlemmar blir överskuggade av Maskens \code{y} och Mullvadens \code{x} men man kan komma åt dem genom att använda punktnotation.

\QUESTEND



\WHAT{Export.}

\QUESTBEGIN

\Task \what~

\Subtask Jämför \code{import} och \code{export} genom att beskriva en likhet och en skillnad. 

\Subtask Skapa ett exempel i REPL som demonstrerar nyttan med \code{export}.

\SOLUTION

\TaskSolved \what~

\SubtaskSolved Likhet: Både \code{import} och \code{export} styr synlighet. Skillnad: \code{import} styr lokal synlighet \emph{inuti} ett objekt medan \code{export} styr synlighet \emph{utanför} ett objekt. 

\SubtaskSolved Man kan med \code{export} på ett smidigt sätt plocka ihop medlemmar från andra objekt och göra dem synliga från mitt eget objekt.
\begin{CodeSmall}
object MittObjekt:
  export java.awt.Color.*  // alla färger blir medlemmar i MittObjekt
  export math.{atan2, Pi}  // atan2 och Pi blir medlemmar i MittObjekt
\end{CodeSmall}

\begin{REPLsmall}
scala> object MittObjekt:
     |   export java.awt.Color.*
     |   export math.{atan2, Pi}  
     | 

scala> MittObjekt.RED
val res0: java.awt.Color = java.awt.Color[r=255,g=0,b=0]

scala> MittObjekt.atan2(3,3) / MittObjekt.Pi
val res1: Double = 0.25
\end{REPLsmall}

\QUESTEND


\WHAT{Tupler.}

\QUESTBEGIN

\Task \what~ Tupler sammanför flera olika värden i ett oföränderligt objekt. Nedan används tupler för att representera en 3D-punkt i underjorden med koordinater \code{(x, y, z)} av typen \code{(Int, Int, Double)}, där $z$-koordinaten anger hur djupt ner i underjorden punkten ligger. På en hemlig plats finns uppgången till överjorden.

\begin{Code}
object Underjorden3D:
  private val hemlis = ("uppgången till överjorden", (0, 0, 0.0))

  object Mullvaden:
    var pos = (5, 3, math.random() * 10 + 1)
    def djup  = ???

  object Masken:
    private var pos = (0, 0, 10.0)
    def ärMullvadsmat: Boolean = ???
    def ärRaktUnderUppgången: Boolean = ???
\end{Code}

\Subtask Funktionen \code{djup} ska ge $z$-koordinaten för Mullvaden. Vilken typ har \code{djup}?

\Subtask Vilken typ har \code{hemlis}?

\Subtask Skriv in koden för \code{Underjorden3D} i en editor och implementera de saknade delarna. Predikatet \code{ärMullvadsmat} ska vara sant om Masken finns på samma plats som Mullvaden. Predikatet  \code{ärRaktUnderUppgången} ska vara sant om $x$- och $y$-koordinaterna sammanfaller med den hemliga uppgången till överjorden. Testa så att dina implementationer fungerar i REPL.

\Subtask En tupel med $n$ värden kallas $n$-tupel. Om man betraktar det tomma värdet  \code{()} som en tupel, vad kan man då kalla detta värde?

\SOLUTION

\TaskSolved \what~

\SubtaskSolved \code{djup} har typen \code{Double}.

\SubtaskSolved \code{hemlis} har typen \code{(String, (Int, Int, Double))}.


\SubtaskSolved
\begin{Code}
object Underjorden3D:
  private val hemlis = ("uppgången till överjorden", (3, 4, 0.0))

  object Mullvaden:
    var pos = (5, 3, math.random() * 10 + 1)

    def djup: Double  = pos._3

  object Masken:
    private var pos = (0, 0, 10.0)

    def ärMullvadsmat: Boolean = pos == Mullvaden.pos

    def ärRaktUnderUppgången: Boolean =
      pos._1 == hemlis._2._1 && pos._2 == hemlis._2._2
\end{Code}

\SubtaskSolved Noll-tupeln.

\QUESTEND


\WHAT{Lat initialisering.}

\QUESTBEGIN

\Task \what~ Med \code{lazy val} kan man fördröja initialiseringen.

\Subtask Vad ger raderna 2 och 3 nedan för resultat?
\begin{REPL}
scala> lazy val z = { println("nu!"); Array.fill(1e1.toInt)(0)}
scala> z
scala> z
\end{REPL}

\Subtask Prova ovan igen men med så stor array att minnet blir fullt. När sker allokeringen?

\Subtask Singelobjekt är lata. Initialiseringsordningen kan bli fel.
\begin{Code}
object test:
  object zzz    { val a = { println("nu!"); 42} }
  object buggig { val a = b ; val b = 42        }
  object funkar { lazy val a = b; val b = 42    }
\end{Code}
\noindent Klistra in modulen \code{test} i REPL. När skrivs \code{"nu!"} ut?

\Subtask Vad händer i REPL om du refererar de tre olika \code{a}-variablerna?

\Subtask Vad är det för skillnad på \code{ lazy val a = uttryck } och \code{ def b = uttryck }?

\SOLUTION

\TaskSolved \what~

\SubtaskSolved \code{"nu!"} skrivs bara ut första gången \code{z} används.
\begin{REPL}
scala> z
nu!
val res19: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

scala> z
val res20: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
\end{REPL}

\SubtaskSolved Allokeringen av arrayen sker första gången \code{z} används (och inte vid deklarationen).
\begin{REPL}
scala> lazy val z = { println("nu!"); Array.fill(1e9.toInt)(0)}
val z: Array[Int] = <lazy>

scala> z
nu!
java.lang.OutOfMemoryError: Java heap space
\end{REPL}

\SubtaskSolved Nej, utskriften av \code{"nu!"} sker först när singelobjektet \code{zzz} används för första gången. Vi borde lägga initialiseringen av \code{b} före \code{a} eller göra \code{a} till en \code{lazy val}.

\SubtaskSolved
\begin{REPL}
scala> import test.*
import test.*

scala> zzz.a      // först när vi använder zzz skrivs "nu!"
nu!               // detta skedde *inte* när vi importerade test
val res0: Int = 42

scala> buggig.a   // a blir 0 eftersom b inte är initialiserad
val res1: Int = 0

scala> funkar.a   // med lazy val unviker vi problemet
val res2: Int = 42


scala> zzz.a     // andra gången är init redan gjort och ingen "nu!"
val res3: Int = 42
\end{REPL}

\SubtaskSolved \code{lazy val a = uttryck} innebär att initialiseringsuttrycket evalueras \emph{en} gång, men evalueringen skjuts på framtiden tills det eventuellt händer att namnet \code{a} används, medan \code{ def b = uttryck } innebär att funktionskroppens uttryck evalueras \emph{varje gång} namnet \code{b} (eventuellt) används.


\QUESTEND



\WHAT{Extensionsmetoder.}

\QUESTBEGIN

\Task \what~Extensionsmetoder möjliggör punktnotation på värden av befintliga typer.

\Subtask Skapa extensionsmetod på heltal som möjliggör inkrementering. 
\begin{REPLnonum}
scala> 42.inc
val res0: Int = 43
\end{REPLnonum} 

\Subtask Skapa extensionsmetod på heltal som möjliggör dekrementering.
\begin{REPLnonum}
scala> 42.dec
val res1: Int = 41
\end{REPLnonum}

\Subtask Sammanför extensionsmetoderna i så att de blir \emph{kollektiva}, alltså under en och samma \code{extension}. Använd även \code{math.incrementExact} och \code{math.decrementExact} efter att du söka upp dokumentationen för dessa här: \url{https://docs.oracle.com/en/java/javase/17/docs/api/}

\Subtask Vad är fördelen med  \code{math.incrementExact} och \code{math.decrementExact}?


\WHAT{Jar-fil. Classpath. Paket.}

\SOLUTION

\TaskSolved \what~

\SubtaskSolved 
\begin{REPLnonum}
scala> extension (i: Int) def inc = i + 1
\end{REPLnonum}

\SubtaskSolved 
\begin{REPLnonum}
scala> extension (i: Int) def dec = i - 1
\end{REPLnonum}

\SubtaskSolved 
\begin{Code}
extension (i: Int) 
  def inc = math.incrementExact(i)
  def dec = math.decrementExact(i)
\end{Code}

\SubtaskSolved Med  \code{math.incrementExact} och \code{math.decrementExact} ges exception om vi går över gränsen:
\begin{REPLnonum}
scala> math.incrementExact(Int.MaxValue)
java.lang.ArithmeticException: integer overflow
  at java.base/java.lang.Math.incrementExact(Math.java:1023)
  at scala.math.incrementExact(package.scala:418)
  ... 34 elided
\end{REPLnonum}


\QUESTEND



\QUESTBEGIN

\Task \what~En jar-fil används för att samla färdigkompilerade program, kod, dokumentation, resursfiler, etc, i en enda fil. En jar-fil är komprimerad på samma sätt som en zip-fil. I kursen använder vi ett paket med namnet \code{introprog} som ligger i en jarfil som heter något i stil med \LibJar~ (eller senare version) där första numret anger den Scala-version som biblioteket är kompilerat för och andra numret anger bibliotekets version som ändras vid varje ny utgåva.

\Subtask På veckans laboration ska vi använda klassen \code{PixelWindow} som finns i paketet \code{introprog}. Vilka parametrar har klassen \code{PixelWindow} och vilka defaultargument finns? Hur skriver man om man vill skapa en \code{PixelWindow}-instans?

\emph{Tips:}  Läs dokumentationen av \code{PixelWindow} här: \url{http://cs.lth.se/pgk/api/}
och leta efter beskrivningen av klassens konstruktor.

\Subtask Ladda ner senaste utgåvan av jar-filen med \code{introprog}-paketet här: \\\url{https://github.com/lunduniversity/introprog-scalalib/releases}
\\ Spara filen som heter \LibJar~(eller senare version) på lämplig plats. 

\Subtask Testa \code{PixelWindow} i REPL enligt nedan. Använd optionen \texttt{-cp} med jar-filens namn som argumentet. Optionen \code{cp} är en förkortning av \emph{classpath} och med den gör du så att maskinkoden för introprog-paketet blir synlig i REPL.  Skriv kod som ritar en kvadrat med sidan $100$ och som har sitt vänstra, övre hörn i punkten $(100,100)$, genom att fortsätta på nedan påbörjade kod (anpassa namnet på jar-filen efter den version som du laddat ned): 

\begin{REPL}
> scala -cp introprog_3-1.3.1.jar
scala> val w = new introprog.PixelWindow(400,300,"HEJ")
scala> w.line(100, 100, 200, 100)
scala> w.line(200, 100, 200, 200)
scala> // fortsätt så att en hel kvadrat ritas
\end{REPL}

\Subtask Studera dokumentationen av metoden \code{line} i \code{PixelWindow} här:\\ \url{http://cs.lth.se/pgk/api/}
\\ Skriv sedan nedan program med en editor i filen \code{hello-window.scala} och fyll i de saknade delarna så att en röd kvadrat ritas ut.

\begin{Code}
package hello

object Main:
  val w = new introprog.PixelWindow(400, 300, "HEJ")

  var color = java.awt.Color.red

  /** Kvadrat med övre hörnet i punkten p och storleken side pixlar. */
  def square(p: (Int, Int))(side: Int): Unit =
    if side > 0 then
      // side == 1 ger en kvadrat som är en enda pixel
      val d = side - 1  

      w.line(p._1,     p._2,     p._1 + d, p._2,     color)
      w.line(p._1 + d, p._2,     p._1 + d, p._2 + d, color)
      w.line(p._1 + d, p._2 + d, p._1,     p._2 + d, color)
      ???

  def main(args: Array[String]): Unit =
    println("Rita kvadrat:")
    square(300,100)(50)
\end{Code}

\noindent
När du kompilerar ditt program, behöver du lägga \LibJar~till classpath.
När du sedan ska köra ditt program behöver du förutom  \LibJar~också lägga \emph{aktuell} katalog till classpath. Om man vill ha flera saker på classpath behövs en lista med sökvägar inom citationstecken och ett kolon som separator\footnote{Kolon används i Linux och macOS, medan Windows använder semikolon.}, till exempel \code{"sökväg1:sökväg2:sökväg3"}.
Aktuell katalog (där katalogen \code{hello} med dina kompilerade byte-kodfiler finns) anges med en punkt.

Använd följande kommando (om du kör Windows så använd semikolon i stället för kolon). Du kan behöva anpassa jar-filens namn om det finns en senare version:
\begin{REPL}
> code .     #skapa filen hello-window.scala med koden ovan
> scalac -cp introprog_3-1.3.1.jar hello-window.scala
> ls hello
> scala -cp "introprog_3-1.3.1.jar:." hello.Main
\end{REPL}
\noindent Du ska nu få upp ett fönster med en liten, röd kvadrat till höger i fönstret.


\SOLUTION

\TaskSolved \what~

\SubtaskSolved Enligt dokumentationen har \code{PixelWindow}-klassen dessa parametrar:
%new PixelWindow(width: Int = 800, height: Int = 640, title: String = "PixelWindow", background: Color = java.awt.Color.black, foreground: Color = java.awt.Color.green)
\begin{itemize}[nolistsep,noitemsep]
  \item \code{width : Int} anger fönstrets bredd, defaultargument \code{800}
  \item \code{height: Int} anger fönstrets höjd, defaultargument \code{640}
  \item \code{title : String} anger fönstrets titel, defaultargument \code{"PixelWindow"}
  \item \code{background: Color} anger bakgrundsfärg, defaultargument \code{java.awt.Color.black}
  \item \code{foreground: Color} anger bakgrundsfärg, defaultargument \code{java.awt.Color.green}
\end{itemize}
Man kan skapa nya fönsterinstanser till exempel så här:
\begin{Code}
val w1 = new introprog.PixelWindow()
val w2 = new introprog.PixelWindow(100, 200, "Mitt fina nya fönster")
\end{Code}

\SubtaskSolved --

\SubtaskSolved
\begin{REPL}
> scala -cp introprog_3-1.3.1.jar
scala> val w = new introprog.PixelWindow(400,300,"HEJ")
scala> w.line(100, 100, 200, 100)
scala> w.line(200, 100, 200, 200)
scala> w.line(200, 200, 100, 200)
scala> w.line(100, 200, 100, 100)
\end{REPL}

\SubtaskSolved
\begin{Code}
package hello

object Main:
  val w = new introprog.PixelWindow(400, 300, "HEJ")

  var color = java.awt.Color.red

  def square(p: (Int, Int))(side: Int): Unit =
    if side > 0 then
      // side == 1 ger en kvadrat som är en enda pixel
      val d = side - 1  
      
      w.line(p._1,     p._2,     p._1 + d, p._2,     color)
      w.line(p._1 + d, p._2,     p._1 + d, p._2 + d, color)
      w.line(p._1 + d, p._2 + d, p._1,     p._2 + d, color)
      w.line(p._1,     p._2 + d, p._1,     p._2,     color)

  def main(args: Array[String]): Unit =
    println("Rita kvadrat:")
    square(300,100)(50)

\end{Code}


\QUESTEND



\WHAT{Färg.}

\QUESTBEGIN

\Task \what~ Det finns många sätt att beskriva färger.
I naturligt språk har vi olika namn på färgerna, till exempel \emph{vitt}, \emph{rosa} och \emph{magenta}.
I bildminnen i datorer är det vanligt att beskriva färger som en blandning av \emph{rött}, \emph{grönt} och \emph{blått} i det så kallade RGB-systemet.

På veckans labb ska vi använda \code{PixelWindow}, som beskriver RGB-färger med klassen \code{java.awt.Color}.
Det finns några fördefinierade färger i \code{java.awt.Color}, till exempel \code{java.awt.Color.black} för svart och \code{java.awt.Color.green} för grönt, se vidare dokumentationen för \code{java.awt.Color} i JDK\footnote{\JDKApiUrl}.
Andra färger kan skapas genom att du själv anger den specifika mängden rött, grönt och blått som behövs för att blanda en viss färg.
Den tre parametrarna till \code{new java.awt.Color(r, g, b)} anger hur mycket \emph{rött}, \emph{grönt} respektive \emph{blått} som färgen ska innehålla, och mängderna ska vara i intervallet 0--255.
Färgen $(153, 102, 51)$ innebär ganska mycket rött, lite mindre grönt och ännu mindre blått och det upplevs som brunt.


\Subtask
På laborationen behöver du dessa tre brunaktiga färger och det är smidigt att samla dem i en egen namnrymd via ett singelobjekt som heter \code{Color} enligt nedan.
\begin{Code}
object Color:
  val mole   = new java.awt.Color( 51,  51,   0)
  val soil   = new java.awt.Color(153, 102,  51)
  val tunnel = new java.awt.Color(204, 153, 102)
\end{Code}
\noindent Men vi vill helst göra import på \code{java.awt.Color} för att kunna använda klassens namn utan att upprepa hela sökvägen, trots att namnet krockar med namnet på vårt singelobjekt. Skriv om koden ovan med hjälp av namnbyte vid import så att färgerna kan skapas med \code{new JColor(...)}. Gör importen lokalt i singelobjektet \code{Color}.



\noindent\begin{minipage}{0.82\textwidth}
\Subtask Inspireras av REPL-experimenten nedan och ändra ditt program i \code{hello-window.scala} så att \emph{tre} överlappande färgfyllda kvadrater ritas enligt den övre bilden till höger. I stället för att rita med den färdiga metoden \code{fill} som finns i \code{PixelWindow}, ska du träna på iteration genom att själv implementera ritprocedurerna \code{rak} och \code{fyll} enligt nedan.
  Proceduren \code{rak} ska rita en horisontell linje med vänstra punkten \code{p} och med längden \code{d} pixlar. Proceduren \code{fyll} ska, med många horisontell linjer, rita en fylld kvadrat med övre vänstra hörnet i punkten \code{p} och sidan \code{s} pixlar. Det som ritas ut ska se ut som den övre bilden till höger. Om du t.ex. tar med en pixel för mycket i dina koordinatberäkningar kan det bli som i den felaktiga undre bilden.
\end{minipage}
\hfill\begin{minipage}{0.23\textwidth}
\includegraphics[width=0.8\textwidth]{../img/fyll-rak.png}
\includegraphics[width=0.8\textwidth]{../img/fyll-rak-fel.png}

\end{minipage}

\begin{REPL}
> scala -cp introprog_3-1.2.0.jar -repl
scala> val w = new introprog.PixelWindow(400,300,"Tre nyanser av brunt")
scala> type Pt = (Int, Int)
scala> var color = java.awt.Color.red
scala> def rak(p: Pt)(d: Int) = w.line(p._1, p._2, ???, ???, color)
scala> def fyll(p: Pt)(s: Int) = for i <- ??? do rak((p._1, ???))(s)

scala> object Color:
     |   ???

scala> color = Color.soil
scala> fyll(100,100)(75)

scala> color = Color.tunnel
scala> fyll(100,100)(50)

scala> color = Color.mole
scala> fyll(150,150)(25)
\end{REPL}
Från Scala 3.1.0 så behövs inte optionen \texttt{-repl}.



\Subtask Vid vilka anrop ovan utnyttjas att tupelparenteserna kan skippas?

\SOLUTION

\TaskSolved \what~

\SubtaskSolved
\begin{Code}
object Color:
  import java.awt.{Color as JColor}

  val mole   = new JColor( 51,  51,   0)
  val soil   = new JColor(153, 102,  51)
  val tunnel = new JColor(204, 153, 102)
\end{Code}

\SubtaskSolved

\begin{CodeSmall}
package hello

object Color:
  import java.awt.{Color as JColor}

  val mole   = new JColor( 51, 51,    0)
  val soil   = new JColor(153, 102, 51)
  val tunnel = new JColor(204, 153, 102)


object Main:
  val w = new introprog.PixelWindow(width = 400, height = 300, title = "HEJ")

  type Pt = (Int, Int)

  var color = java.awt.Color.red

  def rak(p:  Pt)(d: Int) = w.line(p._1, p._2, p._1 + d - 1, p._2, color)

  def fyll(p: Pt)(s: Int) = for i <- 0 until s do rak((p._1, p._2 + i))(s)

  def square(p: (Int, Int))(side: Int): Unit = 
    if (side > 0) then
      val d = side - 1  // side == 1 ska ge en kvadrat som är en pixel stor
      w.line(p._1,     p._2,     p._1 + d, p._2,     color)
      w.line(p._1 + d, p._2,     p._1 + d, p._2 + d, color)
      w.line(p._1 + d, p._2 + d, p._1,     p._2 + d, color)
      w.line(p._1,     p._2 + d, p._1,     p._2,     color)

  def main(args: Array[String]): Unit =
    import Color.*
    color = soil
    fyll(100,100)(75)
    color = tunnel
    fyll(100,100)(50)
    color = mole
    fyll(150,150)(25)
\end{CodeSmall}

\SubtaskSolved Vid anropen av \code{rak} och \code{fyll} utnyttjas att man kan skippa tupelparenteserna om ett tupelargument är ensamt i sin parameterlista.



\QUESTEND



\WHAT{Händelser.}

\QUESTBEGIN

\Task \what~På veckans laboration ska du implementera ett enkelt spel där användaren kan styra en blockmullvad med tangentbordet. Med \code{introprog.PixelWindow} kan du hantera de händelser som genereras när användaren trycker ner eller släpper en tangent eller en musknapp.


\Subtask Studera dokumentationen för singelobjektet \code{introprog.PixelWindow.Event}. Vad heter den oföränderliga heltalsvariabel som representerar att en nedtryckning av en tangentbordsknapp har inträffat? Vad har variabeln för värde?

\Subtask Via dokumentationen för av singelobjektet \code{introprog.examples.TestPixelWindow} kan du komma åt koden som implementerar objektet genom att klicka på länken \code{Source} ovanför sökrutan. Vilken rad i huvudprogrammet i \code{main}-metoden tar hand om fallet att en knappnedtryckningshändelse har inträffat?

\Subtask Testa huvudprogrammet i \code{TestPixelWindow} med följande kommando där första argumentet lägger \code{introprog}-paketet på classpath och andra argumentet pekar ut vilken klass som innehåller den \code{main}-metod som ska köras.:
\begin{REPLnonum}
> scala -cp introprog_3-1.2.0.jar introprog.examples.TestPixelWindow
\end{REPLnonum}
Ett testfönster öppnas när \code{main}-metoden körs. Klicka i fönstret på olika ställen och tryck på olika tangenter och observera vad som skrivs ut. Vad skrivs ut när pil-upp-tangenten trycks ned och släpps upp?

\Subtask Med inspiration från implementationen av \code{TestPixelWindow}, skriv ett program som ritar gröna linjer mellan positionerna för varje musknapp-nedtryck och musknapp-uppsläpp som användaren gör. \\\emph{Tips:} När musknappen trycks ned så spara undan positionen i en variabel med namnet \code{start}. När musknappen släpps upp, rita linjen från den sparade positionen till \code{w.lastMousePos}.

\SOLUTION

\TaskSolved \what~

\SubtaskSolved Den oföränderliga heltalsvariabeln \code{KeyPressed} i \code{introprog.PixelWindow.Event} har värdet \code{1}.

\SubtaskSolved Kodraden nedan tar hand om knappnedtryckningsfallet:
\begin{Code}
case PixelWindow.Event.KeyPressed => println(s"lastKey == \$w.lastKey")
\end{Code}

\SubtaskSolved När pil-upp-knappen på tangentbordet trycks ned får \code{w.lastKey} strängvärdet \code{"Up"}. Följande skrivs ut av testprogrammet när pil-upp-tangenten trycks ned och släpps upp:
\begin{REPL}
lastEventType: 1 => KeyPressed
lastKey == Up
lastEventType: 2 => KeyReleased
lastKey == Up
\end{REPL}


\SubtaskSolved En loop som låter användaren rita linjer med musen:
\begin{Code}
var start = (0,0)
while w.lastEventType != PixelWindow.Event.WindowClosed do
  w.awaitEvent(10)  // wait for next event for max 10 milliseconds
  w.lastEventType match {
    case PixelWindow.Event.MousePressed  =>
      start = w.lastMousePos

    case PixelWindow.Event.MouseReleased =>
      w.line(start._1, start._2, w.lastMousePos._1, w.lastMousePos._2)

    case PixelWindow.Event.WindowClosed  =>
       println("Goodbye!");
    case _ =>
  }
  PixelWindow.delay(100) // wait for 0.1 seconds
\end{Code}

\QUESTEND


\clearpage

\ExtraTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\WHAT{Funktioner är objekt med en \code{apply}-metod.}

\QUESTBEGIN

\Task  \what~ \\
Metoden \code{apply} är speciell.
\begin{REPL}
scala> object plus { def apply(x: Int, y: Int) = x + y }
scala> plus.apply(42, 43)
\end{REPL}
Går det att utelämna \code{.apply} och anropa \code{plus} som en funktion?

\SOLUTION

\TaskSolved \what
Ja det går bra att skriva:
\begin{REPL}
scala> plus(42, 43)
\end{REPL}
Kompilatorn fyller i \code{.apply} åt dig.
\QUESTEND


\WHAT{Skapa moduler med hjälp av singelobjekt.}

\QUESTBEGIN

\Task  \what~

\Subtask Undersök i REPL vad uttrycket \code{"päronisglass".split('i')} har för värde.

\Subtask Vad skrivs ut om du med \code{Test()} anropar \code{apply}-metoden nedan?
\begin{CodeSmall}
object stringUtils:
  object split:
    def sentences(s: String): Array[String] = s.split('.')
    def words(s: String): Array[String] = s.split(' ').filter(_.nonEmpty)

  object count:
    def letters(s: String):   Int = s.count(_.isLetter)
    def words(s: String):     Int = split.words(s).size
    def sentences(s: String): Int = split.sentences(s).size

  object statistics:
    var history = ""
    def printFreq(s: String = history): Unit =
      println(s"\n--- FREKVENSANALYS AV:\n\$s")
      println(s"# bokstäver: \${count.letters(s)}")
      println(s"# ord      : \${count.words(s)}")
      println(s"# meningar : \${count.sentences(s)}")
      history = (s"\$history \$s").trim

object Test:
  import stringUtils.*
  def apply(): Unit =
    val s1 = "Fem     myror är fler än fyra elefanter. Ät gurka."
    val s2 = "Galaxer i mina braxer. Tomat är gott. Päronsplitt."
    statistics.printFreq(s1)
    statistics.printFreq(s2)
    statistics.printFreq()
\end{CodeSmall}

\Subtask Vilket av objekten i modulen \code{stringUtils} har tillstånd? Är det förändringsbart?

\Subtask Ändra metoderna i singelobjektet \code{count} så att de blir extensionsmetoder och kan anropas så här:
\begin{REPLnonum}
scala> import stringUtils.count

scala>  val s = "Hejsan hoppsan. Gurka är gott."
val s: String = Hejsan hoppsan. Gurka är gott.
                                                                                                                               
scala>  (s.nbrOfLetters, s.nbrOfWords, s.nbrOfSentences)
val res0: (Int, Int, Int) = (24,5,2)
\end{REPLnonum}


\SOLUTION


\TaskSolved \what

\SubtaskSolved
\begin{REPLnonum}
scala> "päronisglass".split('i')
val res0: Array[String] = Array(päron, sglass)
\end{REPLnonum}

\SubtaskSolved
\begin{REPLnonum}
scala> Test()
--- FREKVENSANALYS AV:
Fem     myror är fler än fyra elefanter. Ät gurka.
# bokstäver: 36
# ord      : 9
# meningar : 2

--- FREKVENSANALYS AV:
Galaxer i mina braxer. Tomat är gott. Päronsplitt.
# bokstäver: 40
# ord      : 8
# meningar : 3

--- FREKVENSANALYS AV:
Fem     myror är fler än fyra elefanter. Ät gurka. Galaxer i mina braxer. Tomat
är gott. Päronsplitt.
# bokstäver: 76
# ord      : 17
# meningar : 5
\end{REPLnonum}

\SubtaskSolved  Objektet \code{statistics} har ett förändringsbart tillstånd i variabeln \code{history}. Tillståndet ändras vid anrop av \code{printFreq}.

\SubtaskSolved
\begin{Code}
  object count:
    extension (s: String)
      def nbrOfLetters:Int = s.count(_.isLetter)
      def nbrOfWords:Int = split.words(s).size
      def nbrOfSentences: Int = split.sentences(s).size  
\end{Code}


\QUESTEND


\WHAT{Tupler som parametrar.}

\QUESTBEGIN

\Task  \what~ Implementera nedan olika varianter av beräkning av avståndet mellan två punkter. \emph{Tips:} Använd \code{math.hypot}.
\begin{Code}
def distxy(x1: Int, y1: Int, x2: Int, y2: Int): Double = ???
def distpt(p1: (Int, Int), p2: (Int, Int)):     Double = ???
def distp(p1: (Int, Int))(p2: (Int, Int)):      Double = ???

\end{Code}

\SOLUTION

\TaskSolved \what

\begin{Code}
def distxy(x1: Int, y1: Int, x2: Int, y2: Int): Double =
  hypot(x1 - x2, y1 - y2)

def distpt(p1: (Int, Int), p2: (Int, Int)): Double =
  hypot(p1._1 - p2._1, p1._2 - p2._2)

def distp(p1: (Int, Int))(p2: (Int, Int)): Double =
  hypot(p1._1 - p2._1, p1._2 - p2._2)
\end{Code}

\QUESTEND


\WHAT{Tupler som funktionsresultat.}

\QUESTBEGIN

\Task \what~Tupler möjliggör att en funktion kan returnera flera olika värden på samma gång. Implementera funktionen statistics nedan. Den ska returnera en 3-tupel som innehåller antalet element i \code{xs}, medelvärdet av elementen, samt en 2-tupel med variationsvidden $(min, max)$. Ange returtypen explicit i din implementation. Testa så att den fungerar i REPL. \emph{Tips:} Du har nytta av metoderna \code{size}, \code{sum}, \code{min} och \code{max} som fungerar på nummersekvenser.

\begin{Code}
/** Returns the size, the mean, and the range of xs */
def statistics(xs: Vector[Double]) = ???
\end{Code}

\SOLUTION

\TaskSolved \what~

\begin{Code}
def statistics(xs: Vector[Double]): (Int, Double, (Double, Double)) =
  (xs.size, xs.sum / xs.size, (xs.min, xs.max))
\end{Code}

\begin{REPL}
scala> statistics(Vector(0, 2.5, 5))
val res10: (Int, Double, (Double, Double)) = (3,2.5,(0.0,5.0))
\end{REPL}

\QUESTEND




\WHAT{Skapa moduler med hjälp av paket.}

\QUESTBEGIN

\Task \what~

\Subtask Koden nedan ligger i filen \code{paket.scala}. Rita en bild av katalogstrukturen som skapas i aktuellt bibliotek när nedan kod kompileras med: \code{scalac paket.scala}
\begin{Code}
package gurka.tomat.banan

package p1:
  package p11:
    object hello:
      def hello = println("Hej paket p1.p11!")
  package p12:
    object hello:
      def hello = println("Hej paket p1.p12!")

package p2:
  package p21:
    object hello:
      def hello = println("Hej paket p2.p21!")

object Main:
  def main(args: Array[String]): Unit =
    import p1.*
    p11.hello.hello
    p12.hello.hello
    import p2.{p21 as apelsin}
    apelsin.hello.hello
\end{Code}

\Subtask Vad skrivs ut när programmet körs?

\Subtask Får paket ha tillståndsvariabler utan att de placeras inuti ett singelobjekt eller en klass?

\SOLUTION

\TaskSolved \what

\SubtaskSolved

\begin{REPL}
> code paket.scala
> scalac paket.scala
> find . -type d         # linuxkommando som listar alla subkataloger
.
./gurka
./gurka/tomat
./gurka/tomat/banan
./gurka/tomat/banan/p1
./gurka/tomat/banan/p1/p11
./gurka/tomat/banan/p1/p12
./gurka/tomat/banan/p2
./gurka/tomat/banan/p2/p21
\end{REPL}

\SubtaskSolved
\begin{REPL}
> scala gurka.tomat.banan.Main
Hej paket p1.p11!
Hej paket p1.p12!
Hej paket p2.p21!
\end{REPL}

\SubtaskSolved Ja, i Scala 3 får paket ha variabler och funktioner på toppnivå. \\
 \url{https://stackoverflow.com/a/56566166}

\QUESTEND





\AdvancedTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







\WHAT{Värdeanrop och namnanrop.}

\QUESTBEGIN

\Task  \what~Normalt sker i Scala (och i Java) s.k. \emph{värdeanrop} vid anrop av funktioner, vilket innebär att argumentuttrycket evalueras \emph{före} bindningen till parameternamnet sker.

Man kan också i Scala (men inte i Java) med syntaxen \code{=>} framför parametertypen deklarera att \emph{namnanrop} ska ske, vilket innebär att evalueringen av argumentuttrycket \emph{fördröjs} och sker \emph{varje gång} namnet används i metodkroppen.

Deklarera nedan funktioner i REPL.

\begin{Code}
def snark: Int = { print("snark "); Thread.sleep(1000); 42 }
def callByValue(x: Int):   Int = x + x
def callByName(x: => Int): Int = x + x
lazy val zzz = snark
\end{Code}

\noindent Förklara vad som händer när nedan uttryck evalueras.

\Subtask \code{snark + snark}

\Subtask \code{callByValue(snark)}

\Subtask \code{callByName(snark)}

\Subtask \code{callByName(zzz)}

\SOLUTION

\TaskSolved \what

\SubtaskSolved Vid varje anrop av \code{snark} sker en utskrift och en fördröjnig innan $42$ returneras. \\\code{42 + 42 == 84} vilket blir värdet av uttrycket.
\begin{REPL}
scala> snark + snark
snark snark val res1: Int = 84
\end{REPL}

\SubtaskSolved Uttrycket \code{snark} evalueras direkt vid anropet och parametern \code{x} binds till värdet $42$ och i funktionskroppen beräknas $42+42$. Utskriften sker bara en gång.
\begin{REPL}
callByValue(snark)
snark val res2: Int = 84
\end{REPL}

\SubtaskSolved Evalueringen av uttrycket \code{snark} fördröjs tills varje förekomst av parametern \code{x} i funktionskroppen. Utskriften sker två gånger.
\begin{REPL}
callByName(snark)
snark snark val res3: Int = 84
\end{REPL}

\SubtaskSolved Evalueringen av uttrycket \code{zzz} fördröjs tills varje förekomst av parametern \code{x} i funktionskroppen. Utskriften sker en gång eftersom \code{val}-variabler tilldelas sitt värde en gång för alla vid den fördröjda initialiseringen.
\begin{REPL}
callByName(zzz)
snark val res4: Int = 84
\end{REPL}

\QUESTEND




\WHAT{Skapa din egen kontrollstruktur med hjälp av namnanrop.}

\QUESTBEGIN

\Task  \what~

\Subtask Deklarera denna procedur i REPL:
\begin{Code}
def görDettaTvåGånger(b: => Unit): Unit = { b; b }
\end{Code}

\Subtask Anropa \code{görDettaTvåGånger} med ett block som parameter. Blocket ska innehålla en utskriftssats. Förklara vad som händer.

\Subtask Använd namnanrop i kombination med en uppdelad parameterlista och skapa din egen kontrollstruktur enligt nedan.\footnote{Det är så loopen \code{upprepa} i Kojo är definierad.}
\begin{Code}
def upprepa(n: Int)(block: => Unit): Unit =
  var i = 0
  while i < n do 
    ???
\end{Code}

\Subtask
Testa din kontrollstruktur i REPL. Låt upprepa 100 gånger att ett slumptal mellan 1 och 6 dras och sedan skrivs ut.

\Subtask Fördelen med \code{upprepa} är att den är koncis och lättanvänd. Men den är inte lika lätt att använda om man behöver tillgång till en loopvariabel. Implementera därför nedan kontrollstruktur.

\begin{Code}
def repeat(n: Int)(p: Int => Unit): Unit = 
  var i = 0
  while i < n do
    ??? 
\end{Code}

\Subtask Använd \code{repeat} för att 100 gånger skriva ut loopvariabeln och ett slumpdecimaltal mellan 0 och 1.


\SOLUTION

\TaskSolved \what

\SubtaskSolved Blocket är ett uttryck som har värdet \code{(): Unit}. Evalueringen av blocket sker där namnet \code{b} förekommer i procedurkroppen, vilket är två gånger.
\begin{REPL}
scala> görDettaTvåGånger { println("goddag") }
goddag
goddag
\end{REPL}

\SubtaskSolved
\begin{Code}
def upprepa(n: Int)(block: => Unit): Unit =
  var i = 0
  while i < n do
    block
    i += 1
\end{Code}

\SubtaskSolved
\begin{Code}
upprepa(100) {
  val tärningskast = (math.random() * 6 + 1).toInt
  print(s"\$tärningskast ")
}
\end{Code}


\SubtaskSolved
\begin{Code}
def repeat(n: Int)(p: Int => Unit): Unit = 
  var i = 0
  while i < n do
    p(i)
    i += 1
\end{Code}

\SubtaskSolved
\begin{Code}
repeat(100){ i =>
  print(s"\$i: ")
  println(math.random())
}
\end{Code}



\QUESTEND


\WHAT{Hur klara sig utan \code{do while} i Scala 3?} 

\QUESTBEGIN

\Task  \what~I många språk finns en konstruktion med följande syntax: \code{do <satser> while <villkor>} där \code{<satser>} görs minst en gång innan sanningsvärdet för <villkor> testas. Denna ''bakvända while'' används inte så ofta, men kan vara smidig om man vill köra en repetition minst en gång. 

Denna konstruktion finns i Scala 2 men inte i Scala 3 eftersom nyckelordet \code{do} i Scala 3 används vid valfria klammerparenteser och indenteringssyntax i ''vanliga while''. Ett skäl att det kan anses ok att ta bort \code{do <satser> while <villkor>} är att en ''bakvänd while'' ändå i Scala 3 går att skriva om till en ''vanlig while'' genom att inkludera satserna som ska göras minst en gång i ett block på villkorets plats och låta satserna i loopen vara tomma värdet, alltså:
\begin{Code}
while 
<satser>
<villkor>
do ()  
\end{Code}

\Subtask Nedan funkar i Scala 2, men vad händer om du försöker göra detta i Scala 3:
\begin{REPLnonum}
> scala-cli repl -S 2
Welcome to Scala 2.13.8 (OpenJDK 64-Bit Server VM, Java 17.0.3).
Type in expressions for evaluation. Or try :help.

scala> var i = 0
var i: Int = 0

scala> do i += 1 while (i < 10)

scala> i
val res20: Int = 10
\end{REPLnonum}

\Subtask Skriv om ''bakvända'' \code{do while} till en motsvarande ''vanlig'' \code{while do} som fungerar i Scala 3.


\SOLUTION

\TaskSolved \what

\SubtaskSolved Det blir kompileringsfel:
\begin{REPLnonum}
> scala-cli repl -S 3
Welcome to Scala 3.1.3 (17.0.3, Java OpenJDK 64-Bit Server VM).
Type in expressions for evaluation. Or try :help.
                                                                                    
scala> var i = 0
var i: Int = 0
                                                                                    
scala> do i += 1 while (i < 10)
-- [E103] Syntax Error: ----------------------------------------
1 |do i += 1 while (i < 10)
  |^^
  |Illegal start of statement
\end{REPLnonum}

\SubtaskSolved 
\begin{REPLnonum}
> scala-cli repl -S 3
Welcome to Scala 3.1.3 (17.0.3, Java OpenJDK 64-Bit Server VM).
Type in expressions for evaluation. Or try :help.

scala> var i = 0
var i: Int = 0

scala> while
     |   i += 1
     |   i < 10
     | do ()

scala> i
val res0: Int = 10
\end{REPLnonum}



\QUESTEND


\WHAT{Postfixa operatorer för inkrementering och dekrementering.}

\QUESTBEGIN

\Task \what~I många språk, t.ex. Java, C++, C, går det att skriva \code{i++} och \code{i--} om man vill räkna upp eller ner heltalsvariabeln \code{i}. Använd Scalas extensionsmetoder för att göra så att det går att använda operatorerna \code{++} och \code{--} på heltal, enligt nedan:
\begin{REPLnonum}
scala> 42.++
val res0: Int = 43

scala> 42.--
val res1: Int = 41

scala> import language.postfixOps    // tillåter postfix operatornotation

scala> 43 ++
val res2: Int = 44

scala> 43 --
val res3: Int = 42

scala> val i = 42
val i: Int = 42

scala> i++
val res4: Int = 43

scala> i--
val res5: Int = 41
\end{REPLnonum}

\SOLUTION

\TaskSolved \what~

\begin{Code}
extension (i: Int)
  def ++ = i + 1
  def -- = i - 1
\end{Code}


\QUESTEND




\WHAT{Använda färdigt paket: Färgväljare.}

\QUESTBEGIN

\Task \what~På laborationen har du nytta av att kunna blanda egna färger så att du kan rita klarblå himmel och frodigt gräs. Du kan skapa en färgväljare med hjälp av \code{introprog}-paketet enligt nedan.
% \begin{REPL}
% scala> val init = java.awt.Color.black
% scala> def välj() = javax.swing.JColorChooser.showDialog(null, "välj", init)
% scala> välj()
% \end{REPL}
\begin{REPL}
> scala -cp introprog_3-1.3.1.jar
scala> introprog.Dialog.selectColor()
\end{REPL}

\Subtask Vad händer om du trycker \Button{Ok} efter att du valt en grön färg?

\Subtask Vad händer om du trycker \Button{Cancel}~?

\Subtask Vad händer om du trycker \Button{Reset}~?

\Subtask Läs  dokumentationen för metoden \code{selectColor} i singelobjektet \code{Dialog} i paketet \code{introprog}. Anropa \code{selectColor} med default-färgen \code{java.awt.Color.green}.

\SOLUTION

\TaskSolved \what~

\Subtask Den valda färgen returneras efter att användaren tryckt \Button{OK}
\begin{REPL}
scala> introprog.Dialog.selectColor()
val res1: java.awt.Color = java.awt.Color[r=0,g=204,b=0]
\end{REPL}


\Subtask Default-färgen röd returneras efter att användaren tryckt \Button{Cancel}

\Subtask Färgväljaren återgår till default-färgen.

\QUESTEND



\WHAT{Använda färdigt paket: användardialoger.}

\QUESTBEGIN

\Task \what~

\Subtask Läs om dokumentationen för singelobjektet \code{Dialog} i paketet \code{introprog}.

\Subtask Använd proceduren \code{introprog.Dialog.show} och ge ett meddelande till användaren att det är \code{"Game over!"}.
% \begin{REPL}
% scala> import javax.swing.JOptionPane
% scala> def msg(s: String) = JOptionPane.showMessageDialog(null, s)
% \end{REPL}

\Subtask Använd funktionen \code{introprog.Dialog.input} för att visa frågan \code{"Vad heter du?"} och ta reda på användarens namn. Vad händer om användaren klickar \emph{Cancel}?
% \begin{REPL}
% scala> def input(msg: String) = JOptionPane.showInputDialog(null, msg)
% \end{REPL}

\Subtask Använd funktionen \code{introprog.Dialog.select} för att be användaren välja mellan sten, sax och påse. Vad är returtypen?
% \begin{REPL}
% scala> import JOptionPane.{showOptionDialog as showOpt}
% scala> def choice(msg: String, opt: Vector[String], title: String = "?") =
%   showOpt(null, msg, title, 0, 0, null, opt.toArray[Object], opt(0))
% \end{REPL}


\SOLUTION

\TaskSolved \what~

\SubtaskSolved
\begin{REPL}
scala> introprog.Dialog.show("Game over!")
\end{REPL}

\SubtaskSolved Funktionen \code{input} returnerar en sträng som blir tomma strängen \code{""} om användaren klickar \Button{Cancel}
\begin{REPL}
scala> val name = introprog.Dialog.input("Vad heter du?")
name: String = Oddput Superkodare
\end{REPL}

\SubtaskSolved Funktionen \code{select} returnerar en sträng med texten på knappen som användaren tryckte på.
\begin{REPL}
scala> introprog.Dialog.select("Vad väljer du?",Vector("Sten","Sax","Påse"))
val res4: String = Påse
\end{REPL}

\QUESTEND




\WHAT{Skapa din egen \code{jar}-fil.}

\QUESTBEGIN

\Task\Uberkurs  \what~

\Subtask Skriv kommandot \code{jar} i terminalen och undersök vad det finns för optioner. Se speciellt ''Example 1.'' i hjälputskriften. Vilket kommando ska du använda för att packa ihop flera filer i en enda jar-fil? Notera att man (konstigt nog) inte ska ha streck före optionerna när man använder kommandot \code{jar} enligt exempel 1.

\Subtask Skapa med en editor i filen \code{hello.scala} ett enkelt program som skriver ut \texttt{"Hello package!"} eller liknande. Koden ska ligga i paketet \code{hello} och innehålla ett object \code{Main} med en \code{main}-metod.

\Subtask Skriv kommando i terminalen som förpackar koden i en jar-fil med namnet \code{my.jar} och kör igång REPL med jar-filen på classpath. Anropa din \code{main}-funktion i REPL genom att ange sökvägen \textit{\texttt{paketnamn.objektnamn.metodnamn}} med en tom array som argument.

\Subtask Med vilket kommando kan du köra det kompilerade och jar-förpackade programmet direkt i terminalen (alltså utan att dra igång REPL)?

\SOLUTION

\TaskSolved \what

\SubtaskSolved

\texttt{jar cvf \textit{<namn på skapad jar-fil> <namn på det som ska packas>}}

\SubtaskSolved
\begin{Code}
package hello

object Main:
  def main(args: Array[String]): Unit = println("Hello package!")
\end{Code}

\SubtaskSolved
\begin{REPL}
> scalac hello.scala
> jar cvf my.jar hello
> ls
> scala -cp my.jar
scala> hello.Main.main(Array())
\end{REPL}

\SubtaskSolved
\begin{REPL}
> scala -cp my.jar hello.Main
\end{REPL}

\QUESTEND




\WHAT{Hur stor är JDK8?}

\QUESTBEGIN

\Task\Uberkurs \what~ Ta med hjälp av \url{http://stackoverflow.com/} reda på hur många klasser och paket det finns i Java-plattformen JDK8.

\SOLUTION

\TaskSolved \what~Med JDK8-plattformen kommer 4240 färdiga klasser, som är organiserade i 217 olika paket. Se Stackoverflow: \\\url{http://stackoverflow.com/questions/3112882}

\QUESTEND
