\documentclass[article, a5paper]{memoir}

\def\mydate{\leavevmode\hbox{\the\year-\twodigits\month-\twodigits\day}}
\def\twodigits#1{\ifnum#1<10 0\fi\the#1}

\newcommand{\Version}{Compiled \mydate }

\let\footruleskip\undefined\usepackage{fancyhdr}% http://ctan.org/pkg/fancyhdr

\usepackage{pgfpages}
\pgfpagesuselayout{resize to}[a4paper]

% Swedish.
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[swedish]{babel}
\usepackage{microtype}


%%% FONT PACKAGES
%\usepackage[sc]{mathpazo}
%\usepackage[varg]{txfonts}
%\usepackage{times}
%\usepackage{tgtermes}% clone of times
%\usepackage[sfdefault,condensed]{cabin}
\usepackage{PTSansNarrow}\renewcommand*\familydefault{\sfdefault}
%\usepackage{tgcursor}
\usepackage[scaled=0.85]{beramono} % inconsolata or beramono ???
%\usepackage{fouriernc} % serif: new century schoolbook
%\usepackage{avant}     % sans serif: Avant Garde


% Typeblock size, margins.
\settypeblocksize{190mm}{127mm}{*}
\setlrmargins{10.5mm}{*}{*}
\setulmargins{10.0mm}{*}{*}
\setheadfoot{0.1pt}{0.1pt}
\checkandfixthelayout

\usepackage{multicol} \setlength{\columnsep}{5mm}
\usepackage{xcolor}
\usepackage{array}

\definecolor{commentgreen}{rgb}{0,0.4,0}
\definecolor{grammarcolor}{rgb}{0.3,0.6,0.1}
\definecolor{mylinkcolor}{rgb}{0,0.1,0.5}
\definecolor{myemphcolor}{rgb}{0,0.4,0.1}
\definecolor{myalertcolor}{rgb}{0.4,0.1,0}
\definecolor{eclipsepurple}{rgb}{0.5,0,0.25}
\definecolor{eclipseblue}{rgb}{0.16,0,1.0}
\definecolor{eclipsegreen}{rgb}{0,0.5,0}


\newcommand{\OptL}{\textbf{\textcolor{grammarcolor}{~[~}}}
\newcommand{\OptR}{\textbf{\textcolor{grammarcolor}{~]~}}}
\newcommand{\RepL}{\textbf{\textcolor{grammarcolor}{~(~}}}
\newcommand{\RepR}{\textbf{\textcolor{grammarcolor}{~)~}}}
\newcommand{\Or}{\textbf{\textcolor{grammarcolor}{~|~}}}


%---------------------------------------------------------------

\newcommand{\LangColor}{red}

\setlength{\parindent}{0pt}
\raggedright
\raggedbottom
\linespread{0.90}\selectfont
\pagestyle{empty}

\newcommand{\mc}[1]{\multicolumn{2}{l}{\hspace{-0.65em}\parbox[t]{102mm}{\small #1}}}

\newcommand{\ind}{\hspace*{1.5em}}

\newcommand{\head}[1]{{\bfseries {\color{\LangColor}{#1}}\par\vspace{1mm}\hrule\vspace{-2mm}}}

\newenvironment{etab}%
{\begin{ctabular}{@{}>{\raggedright\small}p{25mm} @{}>{\raggedright\small}p{45mm} @{}>{\raggedright\arraybackslash\small}p{57mm}}}
{\end{ctabular}}%


\newcommand{\secend}{\\[1mm]}
\newcommand{\subsecend}{\\ \\[-2mm]}
\renewcommand{\arraystretch}{0.9}

% -----------
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{shapes.geometric, shapes.symbols, arrows, matrix, shapes, positioning}
%https://www.sharelatex.com/blog/2013/08/29/tikz-series-pt3.html
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=1cm, minimum height=1cm, text=white, text centered, draw=black, fill=blue!50!violet]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text=white, text centered, draw=black, fill=red!50!black]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
%UML definitions
\tikzstyle{umlclass}=[rectangle, draw=black,  thick, anchor=north, text width=3cm, rectangle split, rectangle split parts = 3]
\tikzstyle{umlarrow}=[->, >=open triangle 90, thick]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% lingstings specifics:
\usepackage{listings}
\usepackage{upquote} %http://tex.stackexchange.com/questions/145416/how-to-have-straight-single-quotes-in-lstlistings
\lstdefinelanguage{Scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,enum,export,extends,false,final,finally,%
    for,forSome,given,if,implicit,import,lazy,match,%
    new,null,object,override,package,%
    private,protected,return,sealed,%
    super,then,this,throw,trait,true,try,%
    type,val,var,while,with,yield,%
    as, derives, end, extension, infix, inline, opaque, open, transparent, using}, % soft keywords
  otherkeywords={=>,<-,<:,>:,@,=>>,?=>},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}


\lstset{
    language=Scala,
    tabsize=2,
    basicstyle=\ttfamily\selectfont,
    keywordstyle=\bfseries\textcolor{eclipsepurple},
    commentstyle=\textcolor{commentgreen},
    numberstyle={\footnotesize},
    numbers=none,
    %backgroundcolor=\textcolor{gray!15},
    frame=none,
    rulecolor=\color{black!25},
    %title={\footnotesize\lstname},
    breaklines=false,
    breakatwhitespace=false,
    framextopmargin=2pt,
    framexbottommargin=2pt,
    showstringspaces=false,
    columns=fullflexible,keepspaces
}
\lstset{literate=%
{Å}{{\AA}}1
{Ä}{{\"A}}1
{Ö}{{\"O}}1
{Ü}{{\"U}}1
{ß}{{\ss}}1
{ü}{{\"u}}1
{å}{{\aa}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
{æ}{{\ae}}1
{ø}{{\o}}1
{Æ}{{\AE}}1
{Ø}{{\O}}1
{`}{{\`{}}}1
{─}{{\textemdash}}1
{└}{{|}}1
{├}{{|}}1
{│}{{|}}1
}

\newcommand{\code}{\lstinline[basicstyle=\ttfamily]}
\newcommand{\jcode}{\lstinline[basicstyle=\ttfamily,language=Java]}

\lstnewenvironment{Code}[1][]{%
    \lstset{basicstyle=\ttfamily\fontsize{9}{11}\selectfont,#1}%
}{}

%*****************************************************************



\newcommand{\LangRect}[5]{\tikz[overlay, remember picture,inner sep=7pt,minimum height=0.65cm] \node[fill=#2,text=white,rotate=90] at #4 (name) {\large\normalfont\textbf{#1} ~~{\small \thepage(#5)}}; }

\newcommand{\LangRectOdd}[4]{\LangRect{#1}{#2}{#3}{($(current page.north east)-(0.35,#3)$)}{#4}}
\newcommand{\LangRectEven}[4]{\LangRect{#1}{#2}{#3}{($(current page.north west)-(-0.35,#3)$)}{#4}}


\newcommand{\LangMarker}[3]{%param 1 = language, param 2 = offset from top
%\fancyhead{} % clear all header fields
\fancyfoot{} % clear all footer fields
%\fancyfoot[RO]{\thepage}
%\fancyfoot[LE]{\thepage}
\fancyhead{
\ifodd\thepage\LangRectOdd{#1}{\LangColor}{#2}{#3}
\else\LangRectEven{#1}{\LangColor}{#2}{#3}
\fi
}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\pagestyle{fancy}
}

\newcommand{\Newline}{\vspace{\baselineskip}}

\newcommand{\LangTitle}[1]{{\centering \Huge{\bfseries\sffamily \color{\LangColor}{#1}}\par}}

\newcommand{\Comment}[1]{{\color{commentgreen}{#1}}}

\begin{document}

\LangMarker{Scala}{1.5cm}{8}
\LangTitle{Scala 3.1 Quick Ref @ Lund University}
{\centering https://github.com/lunduniversity/introprog/tree/master/quickref \\
{\small \Version. License: CC-BY-SA, \textcopyright~Lund University. Pull requests welcome! Contact: Bjorn Regnell}\\
%{\small Pull requests welcome! Contact: bjorn.regnell at cs.lth.se}
\par}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{0.5em}
\head{Top-level definitions} \vspace{0.75em}
\hspace{0.32em}\begin{minipage}{0.52\linewidth}%
\begin{Code}[frame=single] %[frame=single]  [frame=none]
// in file: hello.scala
package x.y.z

val msg = "Hello"

@main def greet(args: String*): Unit =
  println(s"$msg ${args.mkString(" ")}")
\end{Code}%
\end{minipage}%
\hfill\begin{minipage}{0.45\linewidth}
\raggedright{\small
A compilation unit (here hello.scala) consists of top-level definitions such as val, var, def, import, class and object, which may be preceded by a package clause, e.g.: \code|package x.y.z |that places the compiled files in directory x/y/z/

\begin{tabular}{@{}r @{\hspace{0.5em}}l} \\[-0.5em]
\textbf{Compile}:  & \verb|scalac hello.scala| \\
\textbf{Run}:  &  \verb|scala x.y.z.greet Earth Moon| \\[0.1em]
%&Execution starts in method marked \verb|@main|.
\end{tabular}%
}%
\end{minipage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{-0.25em}
\head{Definitions and declarations}\Newline
{\small\renewcommand{\arraystretch}{0.95}
A \textbf{definition} binds a name to a value/implementation, while a \textbf{declaration} just introduces a name (and type) of an abstract member. Below \code|defsAndDecl| denotes a list of definitions and/or declarations. Template bodies \code|{ ... }| are optional, can be replaced by \code{:} that opens an indentation region.~~~ \code{=}~~also opens an indentation region
\newcommand{\MoveUp}{\\[-0.9em]}
\newcommand{\FirstColWidth}{0.65cm}
\begin{tabular}{@{}p{\FirstColWidth} l l}\\
%\textbf{What} & \textbf{Example} & \textbf{Exlpanation} \\ \hline \\[-0.5em]
Variable
& \code|val x = expr|  & \Comment{Variable x is assigned to expr. A \textbf{val} can only be \textbf{assigned once}.}\\
& \code|val x: Int = 0|  & \Comment{Explicit type annotation,  expr: SomeType allowed after any expr.}\\
& \code|var x = expr|  & \Comment{Variable x is assigned to expr. A \textbf{var} can be \textbf{re-assigned}.} \\
& \code|val x, y = expr| & \Comment{Multiple initialisations, x and y is initialised to the same value.}\\
& \code|val (x, y) = (e1, e2)| & \Comment{Tuple pattern initialisation, x is assigned to e1 and y to e2.}\\
& \multicolumn{2}{l}{\code|val Seq(x, y) = Seq(e1, e2)|  \Comment{Sequence pattern initialisation, x is assigned to e1 and y to e2.}}\\
%& \code|val x: Int = _| & \Comment{Initialized to default value, 0 for number types, null for AnyRef types.}\\
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Function
& \code|def f(a: Int, b: Int): Int = a + b| & \Comment{Function f of type (Int, Int) => Int}\\
& \code|def f(a: Int = 0, b: Int = 0): Int = a + b| & \Comment{Default arguments used if args omitted, f().}\\

&  \code|f(b = 1, a = 3)| & \Comment{{\hspace{-0.25em} Named arguments can be used in any order.}}\\
& \code|def add(a: Int)(b: Int): Int = a + b| & \Comment{Multiple parameter lists, apply: add(1)(2)} \\

& \code|(a: Int, b: Int) => a + b| & \Comment{Anonymous function value, ''lambda''.}\\
& \code|val g: (Int, Int) => Int = (a, b) => a + b| & \Comment{Types can be omitted in lambda if inferable.}\\

%& \multicolumn{2}{l}{\code|f _| \hspace{4.8em} \Comment{Replacing a parameter list with a space and underscore gives the function itself as a value.}}\\

& \multicolumn{2}{l}{\code|val inc = add(1) | \hspace{-4.25em} \Comment{\hspace{6em} Partially applied function add(1) of add above, where inc is of type Int => Int}}\\

& \multicolumn{2}{l}{\code|def addAll(xs: Int*) = xs.sum |  \Comment{\hspace{0.42em} Repeated parameters: addAll(1,2,3) or addAll(Seq(1,2,3)*) }}\\

& \multicolumn{2}{l}{\code|def twice(block: => Unit) = \{ block; block \}| \Comment{\hspace{0.5em} Call-by-name argument evaluated later.}}\\
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Object
& \code|object Name { defsAndDecl } | \Comment{Singleton object auto-allocated when referenced the first time.}
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Class
& \code|class C(parameters) { defsAndDecl }| & \hspace{-3.2em}\Comment{A template for objects to be allocated with \textbf{new} or apply.} \\
& \code|case class C(parameters) { defsAndDecl }| & \Comment{Case class parameters become val members,} \\
& \multicolumn{2}{l}{\Comment{other case class goodies: equals, copy, hashcode, unapply, nice toString, companion object with apply factory.}}\\
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Trait
& \code|trait T(parameters) { defsAndDecl }| & \hspace{-0.5em}\Comment{A trait is like an abstract class, but can be mixed in.}\\
& \code|class C extends D, T| & \hspace{-6.5em}\Comment{A class can only \textbf{extend} one class but \textbf{mix in} many traits separated with \code{,}}\\
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Type
& \code|type A = typeDef | & \Comment{Defines an alias A for the type in typeDef. Abstract if no typeDef.}
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l @{}l}\MoveUp
Import
& \code|import path.to.name | & \Comment{Makes name directly visible. Can be renamed using \textbf{as}}\\
& \code|import path.to.* |   & \Comment{Wildcard \code{*} imports all.}\\
& \code|import path.to.{a, b as x, c as _} | & \Comment{Import several names, b renamed to x, c not imported.}\\
\end{tabular}
}% end small

\vspace{0.25em}
{\small
\begin{tabular}{@{}l @{}l l}
\textbf{Modifier} & \textbf{applies to} & \textbf{semantics}\\ \hline \\[-0.7em]
%\code|private[this] | & definitions, declarations & \Comment{Restricts access to this instance only; also private[p] for package p.} \\
\code|private| & definitions, declarations & \Comment{Restricts access to directly enclosing class and its companion.}\\
\code|override| & definitions, declarations & \Comment{Mandatory if overriding  a concrete definition in a parent class.}\\
\code|final| &  definitions & \Comment{Final members cannot be overridden, final classes cannot be extended.}\\
\code|protected|~~ & definitions& \Comment{Restricts access to subtypes and companion.}\\
\code|lazy| & val definitions & \Comment{Delays initialization of val, initialized when first referenced.}\\
\code|infix| & def definitions & \Comment{Allow alpha-numeric functions in operator notation without warning.}\\
\code|abstract| & class definitions & \Comment{Abstract classes cannot be instantiated (redundant for traits).}\\
\code|sealed| & class definitions & \Comment{Restricts direct inheritance to classes in the same source file.}\\
\code|open| & class definitions & \Comment{Signal intent to be used in inheritance hierarchy. Silences warning.} \\
\end{tabular}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage\vspace*{-2.0em}\head{Constructors and special methods (getters, setters, apply, update), Companion object}\Newline
{\small
\begin{tabular}{@{}l @{}l}
\code|class A(initX: Int = 0):| & \Comment{\textbf{primary constructor}, new is optional creating objects: A(1), default arg: A()} \\
\code|  private var _x = initX| & \Comment{private member only visible in A and its companion object} \\
\code|  def x: Int = _x| & \Comment{getter for private field \_x (name with \_ chosen to avoid clash with x)} \\
\code|  def x_=(i: Int): Unit = | & \Comment{special setter syntax to update attribute using assignment:} \\
\code|    _x = i  | & \Comment{val a = A(1); a.x = 2} \\ \vspace{0.4em}
\code|end A| & \Comment{optional end marker checked by compiler, also allowed: \texttt{end class}} \\
\code|object A: | & \Comment{becomes a \textbf{companion object} if same name and in same code file} \\
\code|  def apply(i: Int = 0) = |  & \Comment{apply is optional: A.apply(1), A(1), A()} \\
\code|    new A(i) |  & \Comment{new is needed here to avoid recursive calls} \\
\code|  val y = A(1)._x | & \Comment{private members can be accessed in companion} \\
\end{tabular}


\vspace{0.4em}
\Comment{Getters and setters above are auto-generated by \textbf{var} in primary constructor:}
 {\hfill\code|class A(var x: Int = 0)|}\\
\Comment{With \textbf{val} in primary constructor only getter, no setter, is generated:}
 {\hfill\code|class A(val x: Int = 0)|} \\
\Comment{\textbf{Private constructor} e.g. to enforce use of factory in companion only:}
{\hfill\code|class A private (var x: Int = 0)|} \\
\Comment{Instead of default arguments, an \textbf{auxiliary constructor} can be defined (less common):} {\hfill\code|def this() = this(0)|}

\vspace{0.2em}\hspace{0.32em}\begin{minipage}{0.65\linewidth}%
{\small\begin{Code}[frame=none]
class IntVec(private val xs: Array[Int]):
  def update(i: Int, x: Int): Unit = { xs(i) = x }
  def apply(i: Int): Int = xs(i)
\end{Code}%
}%
\end{minipage}%
\hfill\begin{minipage}{0.32\linewidth}
\vspace{-0.5em}\raggedright{\small
\Comment{Special syntax for \textbf{update} and \textbf{apply}:} \\
v(0) = 0~\Comment{expanded to} v.update(0,0)\\
v(0)\hspace{1.5em}\Comment{expanded to} v.apply(0)\\
\Comment{where} val v = new IntVec(Array(1,2,3)) \\

}%
\end{minipage}

}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Expressions}\Newline
{\small\renewcommand{\arraystretch}{1.05}
\begin{tabular}{@{}l @{\hspace{0.9em}}l @{\hspace{0.2em}}l}
literals  &  \code|0 0L 0.0 "0" '0' true false|   & \Comment{Basic types e.g. Int, Long, Double, String, Char, Boolean} \\

block     &  \code|{ expr1; ...; exprN } |         &  \Comment{The value of a block is the value of its last expression}   \\
if        &  \code|if cond then expr1 else expr2 |  & \Comment{Value is expr1 if cond is true, expr2 if false (else is optional)} \\
match     &  \code|expr match caseClauses |  &  \Comment{Matches expr against each case clause, see pattern matching. } \\

for       &  \code|for x <- xs do expr |          &   \Comment{Loop for each x in xs, x visible in expr, type Unit }  \\
yield     &  \code|for x <- xs yield expr|     &   \Comment{Yields a sequence with elems of expr for each x in xs }\\
while     &  \code|while cond do expr |           &   \Comment{Loop expr while cond is true, type Unit }\\
%do while  &  \code|do expr while (cond) |        &   \Comment{Do expr at least once, then loop while cond is true, type Unit}\\
throw     &  \code|throw new Exception("Bang!") |  &  \Comment{Throws an exception that halts execution if not in try catch } \\
try       &  \code|val resultOfUnsafeExpr =  |  & \Comment{Evaluate function f: Throwable => T if exception thrown by expr} \\
         &  \code|  try expr catch f |  & \Comment{f for example: } \code|{case e: Exception => someValue}|\\
          & \code|  finally doStuff| & \Comment{finally is optional, doStuff always done even if expr throws} \\
\end{tabular}

\vspace{0.25em}\renewcommand{\arraystretch}{1.05}
\begin{tabular}{@{}l @{\hspace{-1.6em}}r @{\hspace{0.6em}}l | r l}

Evaluation order   & \code|(1 + 2) * 3| & \Comment{parenthesis control order} & \multicolumn{2}{l}{\hspace{-0.2em}\textbf{Precedence} of operators beginning with:}\\

Method application & \code|1.+(2)|  &  \Comment{call method + on object 1} & all letters & \textbf{lowest}\\

Operator notation  & \code|1 + 2|  &   \Comment{same as 1.+(2)} & \code+|+ \\

Conjunction  & \code|c1 && c2|  &  \Comment{true if both c1 \textbf{and} c2 true}  & \code|^|  \\
Disjunction  & \code+c1 || c2+  &  \Comment{true if c1 \textbf{or} c2 true}  & \code|&|  \\
Negation  & \code|!c|          &  \Comment{logical \textbf{not}, false if c is true}  & \code|=  !| \\

Function application  & \code|f(1, 2, 3)|  &   \Comment{same as f.apply(1,2,3)} & \code|<  >|\\

Function literal  & \code|x => x + 1|  &   \Comment{anonymous function, ''lambda''} & \code|:|\\

Object creation  & \code|new C(1,2)|  &   \Comment{class args (1,2) new is optional} & \code|+ -|\\

Self reference  & \code|this|  &  \Comment{refers to the object being defined} & \code|* / %| \\
\vspace{0.4em}

Supertype reference & \code|super.m|  &  \Comment{refers to member m of supertype} & other special chars & \textbf{highest} \\ %\cline{4-5}
Non-referable reference & \code|null|  &  \multicolumn{3}{l}{\hspace{-0.7em}\Comment{refers to null object of type Null} }\\
\multicolumn{5}{l}{\hspace{-0.7em}Uninitialized ~~\Comment{mutable AnyRef field set to null}~~~\code|var x: String = scala.compiletime.uninitialized|} \\
Assignment operator & \code|x += 1|  &  \multicolumn{3}{l}{\hspace{-0.7em}\Comment{expands to~~\code|x = x + 1|~~if no method += is available, works for all operators}} \\
\vspace{-0.4em}\\
Empty tuple, unit value& \code|()|  &  \Comment{the only value of type Unit}  & \multicolumn{2}{l}{\textbf{Integer division and remainder:}} \\
2-tuple value   & \code|(1, "hello")| &  \Comment{same as Tuple2(1, "hello")} & \multicolumn{2}{l}{\code|a / b|  \Comment{~no decimals if a, b Int, Short, Byte }}   \\ \vspace{0.5em}
2-tuple type    & \code|(Int, String)| & \Comment{same as Tuple2[Int, String]} & \multicolumn{2}{l}{\code|a \% b|  \Comment{~fulfills: (a / b) * b + (a \% b) == a}} \\
\multicolumn{5}{l}{\hspace{-0.7em}Tuple prepend~~~\code|3 *: (1.0, '!')| ~\Comment{of type \texttt{Int\,*:\,Double\,*:\,Char\,*:\,EmptyTuple}~~same as (Int, Double, Char)}}\\
\multicolumn{5}{l}{\hspace{-0.7em}Methods on tuples:~~\code|apply drop take head tail zip toArray toIArray toList| }
\end{tabular}
}%end small
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage\vspace*{-2.5em}\head{Pattern matching, type tests}\vspace{0.5em}

\vspace{0.25em}\renewcommand{\arraystretch}{1.0}
{\small%
\begin{tabular}{@{}l @{\hspace{-9.1em}}r}
\code|expr match |
& \Comment{expr is matched against patterns from top until match found, yielding the expression after =>}\\

\code|  case "hello" => expr |
& \Comment{\textbf{literal pattern} matches any value equal (in terms of ==) to the literal}\\

\code|  case x: C => expr |
& \Comment{\textbf{typed variable pattern} matches all instances of C, binding variable x to the instance} \\

\code|  case C(x, y, z) => expr |
& \Comment{\textbf{constructor pattern} matches values of the form C(x, y, z), args bound to x,y,z}\\
\code|  case (x, y, z) => expr  | & \Comment{\textbf{tuple pattern} matches tuple values, alias for constructor pattern Tuple3(x, y, z)}\\

\code|  case x +: xs => expr |
& \Comment{\textbf{sequence extractor patterns} matches head and tail, also x +: y +: z +: xs etc.} \\

\code+  case p1 | ... | pN => expr +
& \Comment{matches if at least one \textbf{pattern alternative} p1, p2 ... or pN  matches} \\

\code|  case x@pattern => expr |
& \Comment{a \textbf{pattern binder} with the @ sign binds a variable to (part of) a pattern} \\


\code|  case x => expr |
& \Comment{\textbf{untyped variable pattern} matches any value, typical ''catch all'' at bottom: \textbf{\texttt{case \_ =>}}} \\

\code|                         | & \Comment{Pattern matching on direct subtypes of a \textbf{sealed} class is checked for exhaustiveness by the compiler} \\
\end{tabular}
}% small

\vspace{0.1em}{\small \Comment{Matching with type pattern} \code| x match { case a: Int => a; case _ => 0 }| \Comment{is preferred over} \\ \Comment{explicit instance test and casting:} \code{ if x.isInstanceOf[Int] then x.asInstanceOf[Int] else 0}}

\vspace{0.5em}\head{Enumerations}

\vspace{0.9em}\renewcommand{\arraystretch}{1.0}
{\small%
\begin{tabular}{@{}l @{\hspace{0.3em}}l}
\code|enum Col:| & \Comment{Col is a sealed class, values in companion of type Col:}~~\code|Col.Red| ~ \Comment{etc.}   \\
\code|  case Red, Green, Blue| & \Comment{Array of values:} \texttt{Col.values(Col.Red.ordinal) == Col.Red} \\
%\vspace*{-0.5em}
& \Comment{value from String:} \code|Col.valueOf("Red") == Col.Red| \\ 
\code|enum Bin(val toInt: Int):| &  \Comment{\textbf{parameterized enum} val is needed for class param to be externally visible.}\\
\code|  case F extends Bin(-1)| & \Comment{get parameter from case value:} \code|Bin.F.toInt == -1|\\
\code|  case T extends Bin(1)| & \Comment{you can also define case members (def, val, etc) inside enums}\\

\end{tabular}
}% small

%\vspace{0.25em}{\small The \textbf{unapply} method can be used in \textbf{extractor} pattern matching (to avoid extra class \& instance), e.g.:}
%
% \vspace{-0.5em}%
% \begin{minipage}{0.6\linewidth}%
% {\small
% \begin{Code}
% object Host {
%   def unapply(s: String): Option[String] =
%     if !s.startsWith("http://") then None
%     else s.stripPrefix("http://").split('/').headOption
% }
% \end{Code}
% }%small
% \end{minipage}%
% \begin{minipage}{0.4\linewidth}
% \vspace{-0.2em}{\hfill\raggedleft\small\Comment{
% \textbf{Extractor object}\\
% extractor must return \textbf{Option} \\ \textbf{None} gives no match in patterns\\
% \textbf{Some(x)} matches in patterns \\
% ~\\
% }}%
% \end{minipage}

% \vspace{-0.5em}{\small\code|str match { case Host(name) => ... }|  {\hfill\Comment{\textbf{Extractor pattern} leads to a call to Host.unapply(str)}}}


\vspace{0.5em}\head{Type parameters, type bounds, variance, ClassTag}\vspace{0.75em}
\renewcommand{\arraystretch}{1.0}
{\small%
\begin{tabular}{@{}l @{\hspace{-10.7em}}r}
\code|class Box[T](val x: T): |
& \Comment{a \textbf{generic class} Box with a \textbf{type parameter} T, allowing x to be of any type}\\

\code|  def pair[U](y: U): (T, U) = (x, y) |
& \Comment{a \textbf{generic method} with \textbf{type parameter} U} \\

\code| |
& \Comment{T is bound to the type of x, U is free in pairedWith, so y can be of any type}\\

\code|val b = Box(0) |
& \Comment{same as (with explicit type parameters):~~~val b: Box\textbf{[Int]} = new Box\textbf{[Int]}(0)}\\

\code|val p: (Box[Int], Box[char]) = b.pair(Box('!'))  |
& \Comment{\textbf{type bounds} \code|>:| supertype~~\code|<:| subtype}\\

\end{tabular}
}% small

\vspace{0.0em}{\small
\Comment{\code|+| \textbf{covariance}~~\code|-| \textbf{contravariance}}~~~~\code|class Box[+T](x: T){ def pair[U >: T](y: U) = (x, y) }| \\
ClassTag needed for generic array constr.: \code|def mkArr[A:reflect.ClassTag](a: A) = Array[A](a)|
}%end small


\vspace{0.5em}\head{scala.\{Option, Some, None\}, scala.util.\{Try, Success, Failure\}
%, scala.concurrent.Future
}\Newline

{\small \textbf{Option[T]} is like a collection with zero or one element. \textbf{Some[T]} and \textbf{None} are subtypes of Option. }

\renewcommand{\arraystretch}{1.0}\vspace{0.25em}
{\small%


\begin{tabular}{@{}l @{\hspace{1.0em}}l}

\multicolumn{2}{l}{\hspace{-0.62em}\code|val opt: Option[String] = if math.random() > 0.9 then Some("bingo") else None|} \\

\code|opt.getOrElse(expr)|
& \Comment{x: T if opt == Some[T](x) else expr}\\

\code|opt.map(x => ... }|
& \Comment{apply x => ... to x if opt is Some(x) else None}\\

\code|opt.get|
& \Comment{x: T if Some[T](x) else throws NoSuchElementException}\\
\end{tabular}

\begin{tabular}{@{}l @{\hspace{1.0em}}r}
\code|opt match { case Some(x) => expr1;  case None => expr2 } |
& \Comment{expr1 if Some(x) else expr2}\\
\end{tabular}
}% small

{\small Other collection-like methods on \textbf{Option}: foreach, isEmpty, filter, toVector, ..., on \textbf{Try}: map, foreach, toOption, ... }


\vspace{0.25em}
{\small\renewcommand{\arraystretch}{1.0}
{\textbf{Try[T]} is like a collection with \textbf{Success[T]} or \textbf{Failure[E]}.\hfill\code|import scala.util.{Try, Success, Failure}|}

\begin{tabular}{@{}l @{\hspace{-4.8em}}r}
\code|Try{ ...; ...; expr1 }.getOrElse(expr2)| & \Comment{evaluates to expr1 if successful or expr2 if exception} \\

\code|Try(expr1).recover{ case e: Exception => expr2 }| & \hspace{5em}\Comment{Success(expr2) if exception else Success(expr1)} \\
\end{tabular}
\code|Try(1/0) match { case Success(x) => x; case Failure(e) => 0 }| %\Comment{~~e is ArithmeticException}
}



\vspace{0.5em}\head{Reading/writing from file, and standard in/out:}\Newline
{\small
\Comment{\textbf{Read} string of lines from \textbf{file}, \code|fromFile| gives BufferedSource, \code|getLines| gives Iterator[String]}
\code|val source = scala.io.Source.fromFile("f.txt", "UTF-8")|  ~~~~\Comment{or \code|fromURL(adr, enc)|}
\code|val lines = try source.getLines.mkString("\n") finally source.close|
}


{\small
\vspace{0.25em}\Comment{\textbf{Read} string from \textbf{standard in} (prompt string is optional) using readLine; \textbf{write} to \textbf{standard out} using println:}
\code|val input = scala.io.StdIn.readLine("> ") | \Comment{} \\ 
\code|println(s"you wrote $input after > using ${input.length} chars")| 

\vspace{0.25em}\Comment{\textbf{Write} string to \textbf{file} after} import java.nio.file.\{Path, Paths, Files\}; import java.nio.charset.StandardCharsets.UTF\_8\vspace{-0.4em}
\begin{Code}
def save(fileName: String, data: String): Path =
    Files.write(Paths.get(fileName), data.getBytes(UTF_8))
\end{Code}
}



\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{-2.5em}\head{The Scala Type System}%\Newline
\vspace{-0.5em}\includegraphics[width=1.05\textwidth,trim=12mm 0 0 0cm]{../img/hierarchy.pdf}

{\small \renewcommand{\arraystretch}{1.01}
\textbf{Number types}\\
\begin{tabular}{@{}l l @{\hspace{0.7em}}l @{\hspace{0.7em}}l @{}p{0.1em} | l l}
\textbf{name} & \textbf{\# bits} & \textbf{range} & \textbf{literal} &   & \multicolumn{2}{l}{\textbf{Methods on numbers}}\\ \cline{1-4}%\hline
& & & &\\[-0.8em]
\texttt{Byte}   &  8  & $-2^7$ ... $2^7-1$  &\texttt{0.toByte} &
& \code|x.abs| & \Comment{math.abs(x), absolute value}\\

\texttt{Short}  &  16 & $-2^{15}$ ... $2^{15}-1$ & \texttt{0.toShort}  &
& \code|x.round| & \Comment{math.round(x), to nearest Long}\\

\texttt{Char}   &  16 & $0$ ... $2^{16}-1$ & \code|'0' '\u0030'| &
& \code|x.floor| & \Comment{math.floor(x), cut decimals}\\

\texttt{Int}    &  32 & $-2^{31}$ ... $2^{31}-1$ & \texttt{0  0xF} &
& \code|x.ceil| & \Comment{math.ceil(x), round up cut decimals}\\

\texttt{Long}   &  64 & $-2^{63}$ ... $2^{63}-1$ & \texttt{0L} &
& \code|x max y| & \Comment{math.max(x, y), gives largest, also min}\\

\texttt{Float}  &  32 & ± $3.4 \cdot 10^{38}$  & \texttt{0F} &
& \code|x.toInt| & \Comment{also toByte, toChar, toDouble etc.}\\

\texttt{Double} &  64 & ± $1.8 \cdot 10^{308}$ & \texttt{0.0} &
& \code|1 to 4| & \Comment{Range.inclusive(1, 4), contains 1,2,3,4}\\ \cline{1-4}
 & & & &
 & \code|0 until 4| & \Comment{Range(0, 4), contains 0,1,2,3}\\

 & & & & &  \code|Int.MinValue| & \Comment{least possible value of type Int}\\
 & & & & &  \code|Int.MaxValue| & \Comment{largest possible value of the Int}\\
  & & & & &   & \Comment{similar for all number types.}  \\
\end{tabular}
}

\Newline\vspace{-5.0em}{\small
Some methods in \code{math} same as in \code{java.lang.Math}:\\
\code{hypot(x, y) sin(x) cos(x) tan(x)}\\
\code{pow(x, y) sqrt(x) log(x) toRadians(x)}\\
\code|floorMod(x, y)| \Comment{similar to x \% y but always positive}

}\Newline\vspace{1em}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Newline\vspace{-2em}\head{The Scala Standard Collection Library}
{
\small\renewcommand{\arraystretch}{1.1}
\begin{multicols}{2}
\texttt{scala.collection.}
\begin{tabular}{@{}l l l}
\texttt{immutable.} & \texttt{mutable.} & methods with good performance: \\
\hline
\texttt{Vector} & \texttt{ArrayBuffer} & \texttt{head tail apply~~+: :+}\\
\texttt{List} &  \texttt{ListBuffer} &  \texttt{head tail~~+:~~::}  \\
\texttt{ArraySeq} & \texttt{ArraySeq} & \texttt{head apply} \\
\texttt{Set} & \texttt{Set} & \texttt{contains~~+~~-}\\
\texttt{Map} & \texttt{Map} & \texttt{apply~~+~~-} \\
\end{tabular}

\vspace{0.2em}

\texttt{String} and \texttt{Array} has implicit conversions that\\ make sequence methods work as for other sequences. \\

\columnbreak

\newcommand{\NodeSkip}{0.5cm}
\begin{center}
\tikzstyle{collectiontype}=[rectangle, draw=black,  thick, anchor=north, text width=1.7cm, rectangle split, rectangle split parts = 1]
\hspace{1.5cm}\begin{tikzpicture}[node distance = \NodeSkip]
\node (Iterable) [collectiontype]  {\texttt{\centerline{Iterable}}};
\node (Seq) [collectiontype, below left = \NodeSkip and 0.05cm of Iterable,text width=1.0cm,]  {\texttt{\centerline{Seq}}};
\node (Set) [collectiontype, right = of Seq, text width=1.0cm,]  {\texttt{\centerline{Set}}};
\node (Map) [collectiontype, right = of Set, text width=1.0cm,]  {\texttt{\centerline{Map}}};
\node (Vector) [collectiontype, below left = \NodeSkip and -0.3cm of Seq, text width=1.0cm,]  {\texttt{\centerline{Vector}}};
\node (List) [collectiontype, below right = \NodeSkip and -0.6cm of Seq, text width=1.0cm,]  {\texttt{\centerline{List}}};
\node (ArraySeq) [collectiontype, below right = \NodeSkip and 0.9cm of Seq, text width=1.2cm,]  {\texttt{\centerline{ArraySeq}}};

\draw[umlarrow] (Seq.north) -- (Iterable.south west);
\draw[umlarrow] (Set.north) -- (Iterable.south);
\draw[umlarrow] (Map.north) -- (Iterable.south east);
\draw[umlarrow] (Vector.north) -- (Seq.south west);
\draw[umlarrow] (List.north) -- (Seq.south);
\draw[umlarrow] (ArraySeq.north) -- (Seq.south east);

\end{tikzpicture}
\end{center}
\end{multicols}
}

\vspace{-0.75em} 
{\small \texttt{Array} has efficient \code{update}, but strange with generics. Special \code{Array} allocation syntax: \code{new Array[Int](n)}  ~~~Prefer \code{ArraySeq} (a "normal" collection, better with generics) or \code{IArray} (an Array that cannot be updated)}

% \vspace{-0.5em}{\small Concrete implementations of \textbf{Set} include HashSet, ListSet and BitSet; collection.\textbf{SortedSet} is implemented by TreeSet.\\
% Concrete implementations of \textbf{Map} include HashMap and ListMap; collection.\textbf{SortedMap} is implemented by TreeMap.
% }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage

\head{Methods in trait \texttt{Iterable[A]}}\Newline

{\small\renewcommand{\arraystretch}{1.16}
\begin{tabular}{@{}l p{3.6cm} p{6.8cm}}
\textbf{What} & \textbf{Usage} & \textbf{Explanation} f is a function, pf is a partial funct., p is a predicate.\\ \hline
Traverse: & \texttt{xs.foreach(f)} & Executes f for every element of xs. Return type Unit.\\ \cline{1-3}

  Add: & \texttt{xs ++ ys} & A new collection with xs followed by ys (concatenation).\\\cline{1-3}

  Map:     
      & \texttt{xs.map(f)} & A new collection created by applying f to every element in xs.\\ \cline{2-3}
      & \texttt{xs.flatMap(f)} & A new collection created by applying f (which must return a collection) to all elements in xs and concatenating the results.\\ \cline{2-3}
       & \texttt{xs.collect(pf)} & A new collection created by applying the pf to every element in xs for which it is defined (undefined ignored).\\ \cline{1-3}

  Convert: & \texttt{toVector toList toSeq toBuffer toArray} & Converts a collection. Unchanged if the run-time type already matches the demanded type.\\ \cline{2-3}
   & \texttt{toSet} & Converts the collection to a set; duplicates removed.\\ \cline{2-3}
   & \texttt{toMap} & Converts a collection of key/value pairs to a map. \\ \cline{1-3}

 %& \texttt{xs copyToBuffer buf } & Copies all elements of xs to buffer buf. Return type Unit.\\ \cline{2-3}
   Array Copy:  & \texttt{xs.copyToArray(arr,s,n)} & Copies at most n elements of xs to array arr starting at index s (last two arguments are optional). Return type Unit.\\ \cline{1-3}

  Size info: & \texttt{xs.isEmpty} & Returns true if the collection xs is empty.\\ \cline{2-3}
   & \texttt{xs.nonEmpty} & Returns true if the collection xs has at least one element.\\ \cline{2-3}
   & \texttt{xs.size} & Returns an \texttt{Int} with the number of elements in xs.\\ \cline{1-3}


  Retrieval: & \texttt{xs.head xs.last} &  	The first/last element of xs (or some elem, if order undefined).\\ \cline{2-3}
      & \texttt{xs.headOption \newline xs.lastOption} & The first/last element of xs (or some element, if no order is defined) in an option value, or \texttt{None} if xs is empty.\\ \cline{2-3}
      & \texttt{xs.find(p)} & An option with the first element satisfying p, or None.\\ \cline{1-3}


  Subparts: & \texttt{xs.tail xs.init} & The rest of the collection except xs.head or xs.last.\\ \cline{2-3}
      & \texttt{xs.slice(from, to)} & The elements in from index \texttt{from} until (not including) \texttt{to}.\\ \cline{2-3}
      & \texttt{xs.take(n)} & The first n elements (or some n elements, if order undefined).\\ \cline{2-3}
      & \texttt{xs.drop(n)} & The rest of the collection except xs take n.\\ \cline{2-3}
      & \texttt{xs.takeRight(n) \newline xs dropRight n} & Similar to \texttt{take} and \texttt{drop}  but takes/drops the last n elements (or any n elements if the order is undefined).\\   \cline{1-3}
      & \texttt{xs.takeWhile(p)} & The longest prefix of elements all satisfying p.\\ \cline{2-3}
      & \texttt{xs.dropWhile(p)} & Without the longest prefix of elements that all satisfy p.\\ \cline{2-3}
      & \texttt{xs.filter(p)} & Those elements of xs that satisfy the predicate p. \\ \cline{2-3}
      & \texttt{xs.filterNot(p)} & Those elements of xs that do not satisfy the predicate p.\\ \cline{2-3}
      & \texttt{xs.splitAt(n)} &  	Split xs at n returning the pair (xs take n, xs drop n).\\ \cline{2-3}
      & \texttt{xs.span(p)} & Split xs by p into the pair (xs takeWhile p, xs.dropWhile p).\\ \cline{2-3}
      & \texttt{xs.partition(p)} & Split xs by p into the pair (xs filter p, xs.filterNot p)\\ \cline{2-3}
      & \texttt{xs.groupBy(f)} & Partition xs into a map of collections according to f.\\ \cline{1-3}


  Conditions: & \texttt{xs.forall(p)} & Returns true if p holds for all elements of xs.\\ \cline{2-3}
      & \texttt{xs.exists(p)} & Returns true if p holds for some element of xs.\\ \cline{2-3}
      & \texttt{xs.count(p)} & An \texttt{Int} with the number of elements in xs that satisfy p.\\ \cline{1-3}

  Folds: & \texttt{xs.foldLeft(z)(op) xs.foldRight(z)(op)} & Apply binary operation op between successive elements of xs, going left to right (or right to left) starting with z.\\ \cline{2-3}
      & \texttt{xs.reduceLeft(op) \newline xs.reduceRight(op)} & Similar to foldLeft/foldRight, but xs must be non-empty, starting with first element instead of z.\\ \cline{2-3}
      & \texttt{xss.flatten} & xss (a collection of collections) is reduced by concatenation.\\ \cline{2-3}
      & \texttt{xs.sum xs.product} & Calculates the sum/product of numeric elements.\\\cline{2-3}
      & \texttt{xs.minOption~xs.maxOption} & ~~Finds a min/max value based on implicitly available ordering.  \\
      & \texttt{xs.minByOption(f)} & Finds a min/max value after applying f to each element. \\\cline{1-3}


\end{tabular}
}


\clearpage

\vspace*{-1.75em}\head{...more methods in trait \texttt{Iterable[A]}}\Newline

{\small\renewcommand{\arraystretch}{1.1}
\begin{tabular}{@{}l p{3.4cm} p{6.8cm}}

\textbf{What} & \textbf{Usage} & \textbf{Explanation} \\ \hline

  Iterators: & \texttt{val it = xs.iterator} & An iterator \texttt{it} of type \texttt{Iterator} that yields each element one by one: \texttt{ while (it.hasNext) f(it.next)}\\   \cline{2-3}

   & \texttt{xs.grouped(size)} & An iterator yielding fixed-sized chunks of this collection.\\\cline{2-3}
   & \texttt{xs.sliding(size)} & An iterator yielding a sliding fixed-sized window of elements.\\\cline{1-3}

  Zippers: & \texttt{xs.zip(ys)} &  	An iterable of pairs of corresponding elements from xs and ys.\\   \cline{2-3}
   & \texttt{xs.zipAll(ys, x, y)} & Similar to \texttt{zip}, but the shorter sequence is extended to match the longer one by appending elements x or y.\\\cline{2-3}
   & \texttt{xs.zipWithIndex} & An iterable of pairs of elements from xs with their indices.\\\cline{1-3}

  Compare: & \texttt{xs.sameElements(ys)} & True if xs and ys contain the same elements in the same order.\\   \cline{1-3}

 Make string: & \texttt{xs.mkString(start, sep, end)} & A string with all elements of xs between separators sep enclosed in strings start and end; start, sep, end are all optional.\\ \cline{1-3}



\end{tabular}
}

\Newline
\head{Methods in trait \texttt{Seq[A]}}\Newline

{\small\renewcommand{\arraystretch}{1.1}
\begin{tabular}{@{}l p{3.75cm} p{6.8cm}}

%\textbf{What} & \textbf{Usage} & \textbf{Explanation} \texttt{f} is function, \texttt{pf} is partial funct., \texttt{p} is predicate.\\ \hline

  Indexing & \texttt{xs(i)  ~ xs.apply(i)} & The element of xs at index i.\\   \cline{2-3}

   and size: & \texttt{xs.length} & Length of sequence. Same as \texttt{size} in \texttt{Iterable}.\\\cline{2-3}
   & \texttt{xs.indices} & Returns a \texttt{Range} extending from 0 until xs.length.\\\cline{2-3}
   & \texttt{xs.isDefinedAt(i)} & True if i is contained in xs.indices.\\\cline{2-3}
   & \texttt{xs.lengthCompare(n)} & Returns -1 if xs is shorter than n, +1 if it is longer, else 0. \\\cline{1-3}


  Index & \texttt{xs.indexOf(x)} & The index of the first element in xs equal to x.\\   \cline{2-3}
  search: & \texttt{xs.lastIndexOf(x)} & The index of the last element in xs equal to x.\\\cline{2-3}
   & \texttt{xs.indexOfSlice(ys) \newline xs.lastIndexOfSlice(ys)} & The (last) index of xs such that successive elements starting from that index form the sequence ys.\\\cline{2-3}
   & \texttt{xs.indexWhere(p)} & The index of the first element in xs that satisfies p.\\\cline{2-3}
   & \texttt{xs.segmentLength(p, i)} & The length of the longest uninterrupted segment of elements in xs, starting with xs(i), that all satisfy the predicate p.\\\cline{2-3}
   & \texttt{xs.prefixLength(p)} &  	Same as \texttt{ xs.segmentLength(p, 0)}\\\cline{1-3}


  Add: & {\texttt{x~+:~xs~~~~~xs~:+~x}}  & Prepend/Append x to xs. Colon on the collection side. \\   \cline{2-3}
   & \texttt{xs.padTo(len, x)} & Append the value x to xs until length len is reached.\\\cline{1-3}


  Update: & \texttt{xs.patch(i, ys, r)} &  A copy of xs with r elements of xs replaced by ys starting at i. \\   \cline{2-3}
   & \texttt{xs.updated(i, x)} & A copy of xs with the element at index i replaced by x.\\\cline{2-3}
   & \texttt{xs(i) = x \newline xs.update(i, x)} & Only available for mutable sequences. Changes the element of xs at index i to x. Return type Unit.\\\cline{1-3}


  Sort: & \texttt{xs.sorted} & A new Seq[A] sorted using implicitly available ordering of A. \\   \cline{2-3}
   & \texttt{xs.sortWith(lt)} &  	A new Seq[A] sorted using less than lt: (A, A) => Boolean.\\\cline{2-3}
   & \texttt{xs.sortBy(f)}   &  	A new Seq[A] sorted by implicitly available ordering of B after applying f: A => B to each element.\\ \cline{1-3}


Reverse: & \texttt{xs.reverse} & A new sequence with the elements of xs in reverse order. \\   \cline{2-3}
   & \texttt{xs.reverseIterator} & An iterator yielding all the elements of xs in reverse order.\\\cline{2-3}
   & \texttt{xs.reverseMap(f)} & Similar to map in Iterable, but in reverse order.\\\cline{1-3}


  Tests: & \texttt{xs.startsWith(ys)} & True if xs starts with sequence ys. \\   \cline{2-3}
   & \texttt{xs.endsWith(ys)} & True if xs ends with sequence ys.\\\cline{2-3}
   & \texttt{xs.contains(x)} & True if xs has an element equal to x.\\\cline{2-3}
   & \texttt{xs.containsSlice(ys)} & True if xs has a contiguous subsequence equal to ys\\\cline{2-3}
   & \texttt{(xs corresponds ys)(p)} & True if corresponding elements satisfy the binary predicate p.\\\cline{1-3}

  Subparts: & \texttt{xs.intersect(ys)} & The intersection of xs and ys, preserving element order.\\\cline{2-3}
   & \texttt{xs.diff(ys)} & The difference of xs and ys, preserving element order.\\\cline{2-3}
   & \texttt{xs.union(ys)} & Same as \texttt{xs ++ ys} in Iterable.\\\cline{2-3}
   & \texttt{xs.distinct} & A subsequence of xs that contains no duplicated element.\\\cline{1-3}



\end{tabular}
}

%\Newline
\vspace*{-0.8em}\head{Mutation methods in trait \texttt{mutable.Buffer[A]}, \texttt{ArrayBuffer[A]}, \texttt{ListBuffer[A]}    }\Newline
{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{5cm}  p{6.6cm}}
\texttt{xs(i) = x~~~~~xs.update(i, x)} & Replace element at index i with x. Return type Unit.\\   \cline{1-2}

\texttt{xs.insert(i, x)~~xs.remove(i)} & Insert x at  \texttt{i}, ret. Unit. Remove elem at i, ret. removed elem.\\   \cline{1-2}

\texttt{xs.append(x)~~~~~xs~+=~x} & Insert x at end.  Return type Unit.\\   \cline{1-2}

\texttt{xs.prepend(x)~~~~x~+=:~xs} & Insert x in front.  Return type Unit.\\   \cline{1-2}

\texttt{xs -= x} & Remove first occurance of x (if exists). Returns xs itself. \\\cline{1-2}

\texttt{xs ++= ys~~~xs.addAll(ys)} & Appends all elements in ys to xs and returns xs itself. \\\cline{1-2}

\end{tabular}
}

\Newline
\vspace*{-0.5em}\head{Methods in trait \texttt{Set[A]}}\Newline

{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{5cm}  p{6.6cm}}

%\textbf{Usage} & \textbf{Explanation} \\ \hline

\texttt{xs(x)~xs.apply(x)~xs.contains(x)} & True if x is a member of xs. \\   \cline{1-2}

\texttt{xs.subsetOf(ys)} & True if xs is a subset of ys.\\\cline{1-2}

\texttt{xs~+~x~~~~~~~~~~xs - x} \newline \texttt{xs~+~(x,~y,~z)~~xs~-~(x,~y,~z)}& Returns a new set including/excluding elements. \newline Addition/subtraction can be applied to many arguments.\\   \cline{1-2}

\texttt{xs.intersect(ys)} & A new set with elements in both xs and ys. Also: \texttt{\&} \\\cline{1-2}
\texttt{xs.union(ys)} & A new set with elements in either xs or ys or both. Also: \texttt{|} \\\cline{1-2}
\texttt{xs.diff(ys)} & A new set with elements in xs that are not in ys. Also: \texttt{\&\textasciitilde} \\\cline{1-2}

\end{tabular}
}

\Newline
\vspace*{-0.5em}\head{Additional mutation methods in trait \texttt{mutable.Set[A]}}\Newline
{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{4.5cm}  p{7.1cm}}

\texttt{xs~+=~x~~~~~xs~-=~x} & Returns the same set with included/excluded elements. \\   \cline{1-2}

\texttt{xs ++= ys~~~xs.addAll(ys)} & Adds all elements in ys to set xs and returns xs itself. \\\cline{1-2}

\texttt{xs.add(x)~~~xs.remove(x)} & Adds/removes x to xs and returns true if xs was mutated, else false. \\\cline{1-2}

%\texttt{xs retain p~~~xs.clear} & Keeps only elements that satisfy predicate p. Remove all.\\   \cline{1-2}
\texttt{xs(x) = b ~ xs.update(x, b)} & If b is true, adds x to xs, else removes x. Return type Unit.\\   \cline{1-2}
%\texttt{xs.clone} & Returns a new mutable set with the same elements as xs.\\   \cline{1-2}

\end{tabular}
}

\Newline
\vspace*{-0.5em}\head{Methods in trait \texttt{Map[K, V]}}\Newline

{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{5.0cm}  p{6.6cm}}

\texttt{ms.get(k)} & The value associated with key k an option, None if not found.\\   \cline{1-2}

\texttt{ms(k)~~~ms.apply(k)} & The value associated with key k, or exception if not found.\\   \cline{1-2}

\texttt{ms.getOrElse(k, d)} & The value associated with key k in map ms, or d if not found.\\   \cline{1-2}

\texttt{ms.isDefinedAt(k)} & True if ms contains a mapping for key k. Also: ms.contains(k) \\   \cline{1-2}


\texttt{ms + (k -> v)  ~~ ms + ((k, v))} \newline \texttt{ms.updated(k, v)} & The map containing all mappings of ms as well as the mapping k -> v from key k to value v. Also: ms + (k1 -> v1, k2 -> v2) \\   \cline{1-2}

\texttt{ms - k} & Excluding any mapping of key k. Also: ms - (k, l, m)\\   \cline{1-2}

\texttt{ms ++ ks} & The mappings of ms with the mappings of ks added/removed.\\   \cline{1-2}

\texttt{ms.keys~~ms.values~~ms.keySet} & An Iterable/Set containing each key/value in ms.\\   \cline{1-2}

\texttt{ms.view.mapValues(f).toMap} & A new Map[K, U] created by applying f: V => U to each value.\\   \cline{1-2}

\end{tabular}
}


\Newline
\vspace*{-0.5em}\head{Additional mutation methods in trait \texttt{mutable.Map[K, V]}}\Newline

{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{5.0cm}  p{6.8cm}}

\texttt{ms(k) = v ~~ ms.update(k, v)} & Adds mapping k to v, overwriting any previous mapping of k.\\   \cline{1-2}

\texttt{ms += (k -> v) ~~~~ ms -= k} & Add or overwrite k -> v / Remove k if key exists or no effect.\\   \cline{1-2}

\texttt{ms.put(k, v) ~~ms.remove(k)}& Adds/removes mapping; returns previous value of k as an option.\\   \cline{1-2}

%\texttt{ms retain p~~~ms.clear} & Keeps mappings with a key satisfying predicate p. Remove all.\\   \cline{1-2}

\texttt{ms.mapValuesInPlace(f)} & Update all values by applying f: (K, V) => V to each pair.\\   \cline{1-2}

%\code|ms.clone| & Returns a new mutable map with the same mappings as ms.\\   \cline{1-2}

\end{tabular}
}

\vspace{0.75em}\head{Factory examples:}\Newline

{\small%
\Comment{On mutable Set, Map:} \code{toSet}, \code{toMap} \Comment{returns immutable};
\hfill\code{Vector(0,0,0)} \Comment{ same as } \code{Vector.fill(3)(0)};
\\
\code{collection.mutable.Set.empty[Int]} \Comment{ same as } \code{collection.mutable.Set[Int]()}\\
\mbox{\code{Map("se" -> "Sweden","nk" -> "Norway")} \Comment{same as }
\code{Map(("se","Sweden"),("nk","Norway"))}}\\
\code{Array.ofDim[Int](3,2)} \Comment{gives} \texttt{Array(Array(0, 0), Array(0, 0), Array(0, 0))} \Comment{same as} \texttt{Array.fill(3,2)(0)};
\texttt{ Vector.iterate(1.2, 3)(\_ + 0.5)} \Comment{gives} \texttt{Vector(1.2, 1.7, 2.2)}\\
\texttt{Vector.tabulate(3)("s" + \_) } \Comment{gives} \code{ Vector("s0", "s1", "s2")}
}




\clearpage

\Newline\head{Strings}\Newline


{\small\renewcommand{\arraystretch}{1.15}

Some methods below are from java.lang.String and some methods are implicitly added from StringOps, etc.\\ Strings are implictly treated as Seq[Char], so all Seq methods also work.

\vspace{0.5em}

\begin{tabular}{@{}l l}
\code|s(i)  s.apply(i)  s.charAt(i)| & \Comment{Returns the character at index i.} \\
\code|s.capitalize| & \Comment{Returns this string with first character converted to upper case.} \\
\code|s.compareTo(t)| & \Comment{Returns x where x < 0 if s < t, x > 0 if s > t, x is 0 if s == t}\\
\code|s.compareToIgnoreCase(t)| & \Comment{Similar to compareTo but not sensitive to case.}\\
\code|s.endsWith(t)| & \Comment{True if string s ends with string t.} \\
\code|s.replace(s1, s2)| & \Comment{Replace all occurances of s1 with s2 in s.} \\
\code|s.split(c)| & \Comment{Returns an array of strings split at every occurance of character c.} \\
\code|s.startsWith(t)| & \Comment{True if string s begins with string t.} \\
\code|s.stripMargin| & \Comment{Strips leading white space followed by | from each line in string.}\\
\code|s.substring(i)| & \Comment{Returns a substring of s with all charcters from index i.}\\
\code|s.substring(i, j)| & \Comment{Returns a substring of s from index i to index j-1.}\\
\code|s.toIntOption  s.toDoubleOption  | & \Comment{Parses s as an Option[Int] or Option[Double] etc. None if invalid.}\\
\code|42.toString   42.0.toString| & \Comment{Converts a number to a String.}\\
\code|s.toLowerCase| & \Comment{Converts all characters to lower case.}\\
\code|s.toUpperCase| & \Comment{Converts all characters to upper case.} \\
\code|s.trim| & \Comment{Removes leading and trailing white space.}\\
\end{tabular}
}



\Newline

{\small\renewcommand{\arraystretch}{1.15}
\begin{tabular}{@{}p{0.7cm} l | r l}
\textbf{Escape} & \textbf{char} & \textbf{Special strings} & \\
\code|\n| & line break & \code|"hello\nworld\t!"| & \Comment{string including escape char for line break and tab}\\
\code|\t| & horisontal tab & \code|"""a "raw" string"""| & \Comment{can include quotes and span multiple lines}\\
\code|\"| & double quote '' & \code|s"x is $x"| & \Comment{\textbf{s interpolator} inserts values of existing names after} \code|$|\\
\code|\'| & single quote ' &  \code|s"x+1 is ${x+1}"|& \Comment{s interpolator evaluates expressions within}  \code|${}|\\
\code|\\| & backslash \textbackslash & \code|f"$x%5.2f"| & \Comment{format Double x to 2 decimals at least 5 chars wide}\\
\code|\u0041| &  unicode for A & \code|f"$y%5d"| & \Comment{format Int y right justified at least five chars wide}\\
\end{tabular}
}



\Newline\head{scala.jdk.CollectionConverters}\Newline

{\small
Enable \code{.asJava} and \code{.asScala} conversions: \code{ import scala.jdk.CollectionConverters.* }
\vspace{0.5em}

\begin{tabular}{@{}r c l}
\texttt{xs.asJava} on a \textbf{Scala} collection of type: & & \texttt{xs.asScala} on a \textbf{Java} collection of type: \\
\texttt{Iterator} &               $\longleftrightarrow$ & \texttt{java.util.Iterator} \\
\texttt{Iterable} &               $\longleftrightarrow$ & \texttt{java.lang.Iterable} \\
\texttt{Iterable} &               $\leftarrow$ & \texttt{java.util.Collection} \\
\texttt{mutable.Buffer} &         $\longleftrightarrow$  & \texttt{java.util.List} \\
\texttt{mutable.Set} &            $\longleftrightarrow$  & \texttt{java.util.Set} \\
\texttt{mutable.Map} &            $\longleftrightarrow$  & \texttt{java.util.Map} \\
\texttt{mutable.ConcurrentMap} &  $\longleftrightarrow$  & \texttt{java.util.concurrent.ConcurrentMap} \\\end{tabular}
}



\Newline\head{Reserved words}\Newline%% TODO: differentiate by color or something hard and soft keywords

{\small These words and symbols have special meaning. Can be used as identifiers if put within \verb|`|backticks\verb|`|.}
\vspace*{-0.5em}
\begin{Code}[morekeywords={macro,\_},otherkeywords={>,<-,\%,<,>:,@,:,=,\#}]
abstract as case catch class def derives do else end enum export extends 
extension false final finally for forSome given if implicit import infix 
inline lazy macro match new null object opaque open override package 
private protected return sealed super then this throw trait transparent 
true try type using val var while with yield
 _   :   =   =>   <-   <:   <%   >:   #   @
\end{Code}
% abstract case catch class def do else extends false final finally for
% forSome if  implicit import lazy macro match new null object override
% package private protected return sealed super this throw trait try true
% type val var while with yield  


\input{java/java-quickref.tex}

\end{document}
